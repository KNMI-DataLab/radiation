<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Gradient Boosting Families</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for Family {mboost}"><tr><td>Family {mboost}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2> Gradient Boosting Families </h2>

<h3>Description</h3>

<p><code>boost_family</code> objects provide a convenient way to specify loss functions
and corresponding risk functions to be optimized by one of the boosting
algorithms implemented in this package.
</p>


<h3>Usage</h3>

<pre>
Family(ngradient, loss = NULL, risk = NULL,
       offset = function(y, w)
           optimize(risk, interval = range(y),
                    y = y, w = w)$minimum,
       check_y = function(y) y,
       weights = c("any", "none", "zeroone", "case"),
       nuisance = function() return(NA),
       name = "user-specified", fW = NULL,
       response = function(f) NA,
       rclass = function(f) NA)
AdaExp()
AUC()
Binomial(link = c("logit", "probit"), ...)
GaussClass()
GaussReg()
Gaussian()
Huber(d = NULL)
Laplace()
Poisson()
GammaReg(nuirange = c(0, 100))
CoxPH()
QuantReg(tau = 0.5, qoffset = 0.5)
ExpectReg(tau = 0.5)
NBinomial(nuirange = c(0, 100))
PropOdds(nuirange = c(-0.5, -1), offrange = c(-5, 5))
Weibull(nuirange = c(0, 100))
Loglog(nuirange = c(0, 100))
Lognormal(nuirange = c(0, 100))
Gehan()
Hurdle(nuirange = c(0, 100))
Multinomial()
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>ngradient</code></td>
<td>
<p> a function with arguments <code>y</code>, <code>f</code> and <code>w</code> implementing the
<em>negative</em> gradient of the <code>loss</code> function (which is to be minimized). </p>
</td></tr>
<tr valign="top"><td><code>loss</code></td>
<td>
<p> an optional loss function with arguments <code>y</code> and <code>f</code>. </p>
</td></tr>
<tr valign="top"><td><code>risk</code></td>
<td>
<p> an optional risk function with arguments <code>y</code>, <code>f</code> and <code>w</code> to be minimized (!),
the weighted mean of the loss function by default. </p>
</td></tr>
<tr valign="top"><td><code>offset</code></td>
<td>
<p> a function with argument <code>y</code> and <code>w</code> (weights)
for computing a <em>scalar</em> offset. </p>
</td></tr>
<tr valign="top"><td><code>fW</code></td>
<td>
<p> transformation of the fit for the diagonal weights matrix for an
approximation of the boosting hat matrix for loss functions other than
squared error.</p>
</td></tr>
<tr valign="top"><td><code>response</code></td>
<td>
<p> inverse link function of a GLM or any other transformation
on the scale of the response.</p>
</td></tr>
<tr valign="top"><td><code>rclass</code></td>
<td>
<p> function to derive class predictions from conditional class
probabilities (for models with factor response variable).</p>
</td></tr>
<tr valign="top"><td><code>check_y</code></td>
<td>
<p> a function for checking and transforming
the class / mode of a response variable.</p>
</td></tr>
<tr valign="top"><td><code>nuisance</code></td>
<td>
<p> a function for extracting nuisance parameters from the family.</p>
</td></tr>
<tr valign="top"><td><code>weights</code></td>
<td>
<p> a character indicating what type of weights are
allowed. These can be either arbitrary (non-negative) weights
code&quot;any&quot;, only zero and one weights <code>"zeroone"</code>,
(non-negative) interger weights <code>"case"</code>, or no weights are
allowed <code>"none"</code>.</p>
</td></tr>
<tr valign="top"><td><code>name</code></td>
<td>
<p> a character giving the name of the loss function for pretty printing. </p>
</td></tr>
<tr valign="top"><td><code>link</code></td>
<td>
<p> link function for binomial family. Alternatively,
one may supply the name of a distribution (for example
<code>link = "norm"</code>), parameters of which may
be specified via the ... argument.</p>
</td></tr>
<tr valign="top"><td><code>d</code></td>
<td>
<p> delta parameter for Huber loss function. If omitted, it is chosen adaptively.</p>
</td></tr>
<tr valign="top"><td><code>tau</code></td>
<td>
<p> the quantile or expectile to be estimated, a number strictly between 0 and 1.</p>
</td></tr>
<tr valign="top"><td><code>qoffset</code></td>
<td>
<p> quantile of response distribution to be used as offset.</p>
</td></tr>
<tr valign="top"><td><code>nuirange</code></td>
<td>
<p> a vector containing the end-points of the interval to be
searched for the minimum risk w.r.t. the nuisance parameter.
In case of <code>PropOdds</code>, the starting values for
the nuisance parameters. </p>
</td></tr>
<tr valign="top"><td><code>offrange</code></td>
<td>
<p> interval to search for offset in.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p> additional arguments to link functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The boosting algorithm implemented in <code><a href="mboost.html">mboost</a></code> minimizes the
(weighted) empirical risk function <code>risk(y, f, w)</code> with respect to <code>f</code>.
By default, the risk function is the weighted sum of the loss function <code>loss(y, f)</code>
but can be chosen arbitrarily. The <code>ngradient(y, f)</code> function is the negative
gradient of <code>loss(y, f)</code> with respect to <code>f</code>.
</p>
<p>Pre-fabricated functions for the most commonly used loss functions are
available as well. Buehlmann and Hothorn (2007) give a detailed
overview of the available loss functions. The <code>offset</code> function
returns the population minimizers evaluated at the response, i.e.,
<i>1/2 \log(p / (1 - p))</i> for <code>Binomial()</code> or <code>AdaExp()</code>
and <i>(&sum; w_i)^{-1} &sum; w_i y_i</i> for <code>Gaussian()</code> and the
median for <code>Huber()</code> and <code>Laplace()</code>. A short summary of the
available families is given in the following paragraphs:
</p>
<p><code>AdaExp()</code>, <code>Binomial()</code> and <code>AUC()</code> implement
families for binary classification. <code>AdaExp()</code> uses the
exponential loss, which essentially leads to the AdaBoost algorithm
of Freund and Schapire (1996). <code>Binomial()</code> implements the
negative binomial log-likelihood of a logistic regression model
as loss function. Thus, using <code>Binomial</code> family closely corresponds
to fitting a logistic model. Alternative link functions
can be specified via the name of the corresponding distribution, for
example <code>link = "cauchy"</code> lead to <code><a href="../../stats/html/Cauchy.html">pcauchy</a></code>
used as link function. This feature is still experimental and
not well tested.
</p>
<p>However, the coefficients resulting from boosting with family
<code>Binomial(link = "logit")</code> are <i>1/2</i> of the coefficients of a logit model
obtained via <code><a href="../../stats/html/glm.html">glm</a></code>. This is due to the internal recoding
of the response to <i>-1</i> and <i>+1</i> (see below).
However, Buehlmann and Hothorn (2007) argue that the
family <code>Binomial</code> is the preferred choice for binary
classification. For binary classification problems the response
<code>y</code> has to be a <code>factor</code>. Internally <code>y</code> is re-coded
to <i>-1</i> and <i>+1</i> (Buehlmann and Hothorn 2007).
<code>AUC()</code> uses <i>1-AUC(y, f)</i> as the loss function.
The area under the ROC curve (AUC) is defined as
<i>AUC = (n_{-1} n_1)^{-1} &sum;_{i: y_i = 1} &sum;_{j: y_j = -1} I(f_i &gt; f_j)</i>.
Since this is not differentiable in <code>f</code>, we approximate the jump function
<i>I((f_i - f_j) &gt; 0)</i> by the distribution function of the triangular
distribution on <i>[-1, 1]</i> with mean <i>0</i>, similar to the logistic
distribution approximation used in Ma and Huang (2005).
</p>
<p><code>Gaussian()</code> is the default family in <code><a href="mboost.html">mboost</a></code>. It
implements <i>L_2</i>Boosting for continuous response. Note
that families <code>GaussReg()</code> and <code>GaussClass()</code> (for regression
and classification) are deprecated now.
<code>Huber()</code> implements a robust version for boosting with
continuous response, where the Huber-loss is used. <code>Laplace()</code>
implements another strategy for continuous outcomes and uses the
<i>L_1</i>-loss instead of the <i>L_2</i>-loss as used by
<code>Gaussian()</code>.
</p>
<p><code>Poisson()</code> implements a family for fitting count data with
boosting methods. The implemented loss function is the negative
Poisson log-likelihood. Note that the natural link function
<i>\log(&mu;) = &eta;</i> is assumed. The default step-site <code>nu = 0.1</code>
is probably too large for this family (leading to
infinite residuals) and smaller values are more appropriate.
</p>
<p><code>GammaReg()</code> implements a family for fitting nonnegative response
variables. The implemented loss function is the negative Gamma
log-likelihood with logarithmic link function (instead of the natural
link).
</p>
<p><code>CoxPH()</code> implements the negative partial log-likelihood for Cox
models. Hence, survival models can be boosted using this family.
</p>
<p><code>QuantReg()</code> implements boosting for quantile regression, which is
introduced in Fenske et al. (2009). <code>ExpectReg</code> works in analogy,
only for expectiles, which were introduced to regression by Newey and Powell (1987).
</p>
<p>Families with an additional scale parameter can be used for fitting
models as well: <code>PropOdds()</code> leads to proportional odds models
for ordinal outcome variables (Schmid et al., 2011). When using this
family, an ordered set of threshold parameters is re-estimated in each
boosting iteration. An example is given below which also shows how to
obtain the thresholds. <code>NBinomial()</code> leads to regression models with
a negative binomial conditional distribution of the response.
<code>Weibull()</code>, <code>Loglog()</code>, and <code>Lognormal()</code> implement
the negative log-likelihood functions of accelerated failure time
models with Weibull, log-logistic, and lognormal distributed outcomes,
respectively. Hence, parametric survival models can be boosted using
these families. For details see Schmid and Hothorn (2008) and Schmid
et al. (2010).
</p>
<p><code>Gehan()</code> implements rank-based estimation of survival data in an
accelerated failure time model. The loss function is defined as the sum
of the pairwise absolute differences of residuals. The response needs to
be defined as <code>Surv(y, delta)</code>, where <code>y</code> is the observed survial
time (subject to censoring) and <code>delta</code> is the non-censoring indicator
(see <code><a href="../../survival/html/Surv.html">Surv</a></code> for details). For details on <code>Gehan()</code> see
Johnson and Long (2011).
</p>
<p>Hurdle models for zero-inflated count data can be fitted by using a combination
of the <code>Binomial()</code> and <code>Hurdle()</code> families. While the <code>Binomial()</code>
family allows for fitting the zero-generating process of the Hurdle model,
<code>Hurdle()</code> fits a negative binomial regression model to the non-zero
counts. Note that the specification of the Hurdle model allows for using
<code>Binomial()</code> and <code>Hurdle()</code> independently of each other.
</p>
<p>Linear or additive multinomial logit models can be fitted using
<code>Multinomial()</code>; although is family requires some extra effort for
model specification (see example).  More specifically, the predictor must
be in the form of a linear array model (see <code><a href="baselearners.html">%O%</a></code>).  Note
that this family does not work with tree-based base-learners at the
moment. The class corresponding to the last level of the factor coding
of the response is used as reference class.
</p>


<h3>Value</h3>

<p>An object of class <code>boost_family</code>.
</p>


<h3>Warning</h3>

<p>The coefficients resulting from boosting with family
<code>Binomial</code> are <i>1/2</i> of the coefficients of a logit model
obtained via <code><a href="../../stats/html/glm.html">glm</a></code>. This is due to the internal recoding
of the response to <i>-1</i> and <i>+1</i> (see above).
</p>
<p>For <code>AUC()</code>, variables should be centered and scaled and observations with weight &gt; 0 must not contain missing values.
The estimated coefficients for <code>AUC()</code> have no probabilistic interpretation.
</p>


<h3>Author(s)</h3>

<p><code>ExpectReg()</code> was donated by Fabian Sobotka.
<code>AUC()</code> was donated by Fabian Scheipl.
</p>


<h3>References</h3>

<p>Peter Buehlmann and Torsten Hothorn (2007),
Boosting algorithms: regularization, prediction and model fitting.
<em>Statistical Science</em>, <b>22</b>(4), 477&ndash;505.
</p>
<p>Nora Fenske, Thomas Kneib, and Torsten Hothorn (2011),
Identifying risk factors for severe childhood malnutrition by
boosting additive quantile regression.
<em>Journal of the American Statistical Association</em>, <b>106</b>:494-510.
</p>
<p>Yoav Freund and Robert E. Schapire (1996),
Experiments with a new boosting algorithm.
In <em>Machine Learning: Proc. Thirteenth International Conference</em>,
148&ndash;156.
</p>
<p>Shuangge Ma and Jian Huang (2005), Regularized ROC method for
disease classification and biomarker selection with microarray
data. <em>Bioinformatics</em>, <b>21</b>(24), 4356&ndash;4362.
</p>
<p>Whitney K. Newey and James L. Powell (1987),
Asymmetric least squares estimation and testing.
<em>Econometrika</em>, <b>55</b>, 819&ndash;847.
</p>
<p>Matthias Schmid and Torsten Hothorn (2008),
Flexible boosting of accelerated failure time models.
<em>BMC Bioinformatics</em>, <b>9</b>(269).
</p>
<p>Matthias Schmid, Sergej Potapov, Annette Pfahlberg,
and Torsten Hothorn (2010). Estimation and regularization techniques for
regression models with multidimensional prediction functions.
<em>Statistics and Computing</em>, <b>20</b>, 139&ndash;150.
</p>
<p>Schmid, M., T. Hothorn, K. O. Maloney, D. E. Weller and S. Potapov
(2011): Geoadditive regression modeling of stream biological
condition. <em>Environmental and Ecological Statistics</em>,
<b>18</b>(4), 709&ndash;733.
</p>
<p>Benjamin Hofner, Andreas Mayr, Nikolay Robinzonov and Matthias Schmid
(2014). Model-based Boosting in R: A Hands-on Tutorial Using the R
Package mboost. <em>Computational Statistics</em>, <b>29</b>, 3&ndash;35.<br />
<a href="http://dx.doi.org/10.1007/s00180-012-0382-5">http://dx.doi.org/10.1007/s00180-012-0382-5</a>
</p>
<p>Available as vignette via: <code>vignette(package = "mboost", "mboost_tutorial")</code>
</p>
<p>Brent A. Johnson and Qi Long (2011) Survival ensembles by the sum of pairwise
differences with application to lung cancer microarray studies.
<em>Annals of Applied Statistics</em>, <b>5</b>, 1081&ndash;1101.
</p>


<h3>See Also</h3>

<p><code><a href="mboost.html">mboost</a></code> for the usage of <code>Family</code>s. See
<code><a href="boost_family-class.html">boost_family-class</a></code> for objects resulting from a call to <code>Family</code>. </p>


<h3>Examples</h3>

<pre>
### Define a new family
MyGaussian &lt;- function(){
       Family(ngradient = function(y, f, w = 1) y - f,
       loss = function(y, f) (y - f)^2,
       name = "My Gauss Variant")
}

############################################################
## Do not run and check these examples automatically as
## they take some time

### Proportional odds model
data(iris)
iris$Species &lt;- factor(iris$Species, ordered = TRUE)
if (require("MASS")) {
    (mod.polr &lt;- polr(Species  ~ Sepal.Length, data = iris))
}
mod.PropOdds &lt;- glmboost(Species  ~ Sepal.Length, data = iris,
                         family = PropOdds(nuirange = c(-0.5, 3)))
mstop(mod.PropOdds) &lt;- 1000
## thresholds are treated as nuisance parameters, to extract these use
nuisance(mod.PropOdds)
## effect estimate
coef(mod.PropOdds)["Sepal.Length"]
## make thresholds comparable to a model without intercept
nuisance(mod.PropOdds) - coef(mod.PropOdds)["(Intercept)"] -
    attr(coef(mod.PropOdds), "offset")

## End(Not run and test)


### Multinomial logit model via a linear array model
## One needs to convert the data to a list
myiris &lt;- as.list(iris)
## ... and define a dummy vector with one factor level less
## than the outcome, which is used as reference category.
myiris$class &lt;- factor(levels(iris$Species)[-nlevels(iris$Species)])
## Now fit the linear array model
mlm &lt;- mboost(Species ~ bols(Sepal.Length, df = 2) %O%
                        bols(class, df = 2, contrasts.arg = "contr.dummy"),
              data = myiris,
              family = Multinomial())
coef(mlm) ## one should use more boosting iterations.
head(round(pred &lt;- predict(mlm, type = "response"), 2))

## Prediction with new data:
newdata &lt;- as.list(iris[1,])
## One always needs to keep the dummy vector class as above!
newdata$class &lt;- factor(levels(iris$Species)[-nlevels(iris$Species)])
pred2 &lt;- predict(mlm, type = "response", newdata = newdata)
## check results
pred[1, ]
pred2

############################################################
## Do not run and check these examples automatically as
## they take some time

## Compare results with nnet::multinom
if (require("nnet")) {
    mlmn &lt;- multinom(Species ~ Sepal.Length, data = iris)
    max(abs(fitted(mlm[1000], type = "response") -
            fitted(mlmn, type = "prob")))

}

## End(Not run and test)


</pre>

<hr /><div style="text-align: center;">[Package <em>mboost</em> version 2.6-0 <a href="00Index.html">Index</a>]</div>
</body></html>
