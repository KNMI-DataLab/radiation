---
title: "Daily Mean Radiation Products from Ground-based observations and Satellite data"
author: "Marieke Dirksen"
date: "September, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r,message=FALSE}
.libPaths("/usr/people/dirksen/R-20160725/x86_64-redhat-linux-gnu-library/3.3/")
library(adehabitat)
library(automap)
library(caret)
library(data.table)
library(doParallel)
library(foreach)
library(GSIF)
library(maptools)
library(reshape)
library(raster)
library(rgdal)
library(rhdf5)
library(SDMTools)
data(wrld_simpl)
```

#Color settings for plotting routine
```{r}
kleur.breaks<-seq(0,500,by=10)
kleur.cols<-terrain.colors(length(kleur.breaks-1))
```

#Daily mean radiation from satellite
```{r,message=FALSE}
pathsat<-"/net/pc150398/nobackup_1/users/meirink/siccs_wouter/SICCS/daymean/"
loc.grid<-"/net/pc150398/nobackup/users/meirink/msg_archive/geo/meteosat9.euro4m.angles.h5"
year.sat<-seq(from=2004,to=2016,by=1)
Y<-year.sat[11]

pathsat.year<-paste0(pathsat,Y)

#selecting a test month
m<-"07"
files.sat<-list.files(path=paste0(pathsat.year,"/",m))
```

```{r,message=FALSE}
setwd(paste0(pathsat.year,"/","07"))

file<-files.sat[1]
d<-gsub("daymean","",file)
d<-gsub("EURO4M.hdf5","",d)
time<-as.POSIXct(paste0(Y,"-",m,"-",d))

#structure of the file
h5ls(file)
data.direct.irradiance<-h5read(file,"direct irradiance")
data.diffuse.irradiance<-h5read(file,"diffuse irradiance")
data.total.irradiance<-data.direct.irradiance+data.diffuse.irradiance
data.total.irradiance<-t(data.total.irradiance)
#the grid file
h5ls(loc.grid)
data.lat<-h5read(loc.grid,"/lat") #Latitude
data.lon<-h5read(loc.grid,"/lon") #Longitude

data.lat[which(data.lat==-999)]<-NA # replace no data value with NA (this case -1)
data.lon[which(data.lon==-999)]<-NA # replace no data value with NA (this case -1)

r<-raster(data.total.irradiance,crs=CRS("+init=epsg:4326"),
      xmn=min(data.lon,na.rm=T),
      xmx=max(data.lon,na.rm=T),
      ymn=min(data.lat,na.rm=T),
      ymx=max(data.lat,na.rm=T))
plot(r,main=paste("Datum=",time),col=kleur.cols,breaks=kleur.breaks,legend=F)
plot(wrld_simpl,add=TRUE)
```

#Reprojecting raster and cropping
```{r,message=FALSE}
pro=CRS("+init=epsg:28992")

#Natural Earth dataset: unprojected shape files
mymap.unpro=readOGR(dsn='/run/media/dirksen/Elements/Final_R_scripts/NaturalEarthData/ne_10m_admin_0_countries',layer="ne_10m_admin_0_countries") # Read in (unprojected) map data
mymap.pro=spTransform(mymap.unpro, pro) # Reproject the map

mymap.unpro_lakes=readOGR(dsn='/run/media/dirksen/Elements/Final_R_scripts/NaturalEarthData/ne_10m_lakes',layer="ne_10m_lakes") # Read in (unprojected) map data
mymap.pro_lakes=spTransform(mymap.unpro_lakes, pro) # Reproject the map

r<-projectRaster(r,crs=pro)
r.NED<-crop(r,extent(12621.630033977,278621.630033977,305583.0457758,620583.0457758))

plot(r.NED,col=kleur.cols,breaks=kleur.breaks,main=paste("Datum=",time),legend=F)
plot(mymap.pro,add=TRUE)
plot(mymap.pro_lakes,add=TRUE)
```

#Data from observations
```{r,message=FALSE}
obs<-fread("/nobackup/users/dirksen/Radiation_Obs_Satellite/Observations_data/radiation_KNMI_day.csv")
obs$IT_DATETIME<-as.POSIXct(obs$IT_DATETIME,format="%Y%m%d_%H%M%S_000000")

obs.subset<-obs[which(IT_DATETIME==time),]
obs.subset<-na.omit(obs.subset,cols=c("DS_LAT","DS_LON"))

coordinates(obs.subset)<-~DS_LON+DS_LAT
proj4string(obs.subset)<-CRS("+init=epsg:4326")
obs.subset<-spTransform(obs.subset,pro)
obs.subset$REH1.Q<-obs.subset$REH1.Q24/24

kleur.data<-cut(obs.subset$REH1.Q,breaks=kleur.breaks,include.lowest=TRUE,labels=FALSE)
plot(obs.subset,bg=(kleur.cols[kleur.data]),
     col="darkgrey",pch=21)
text(obs.subset$DS_LON,obs.subset$DS_LAT,round(obs.subset$REH1.Q,0),pos=3,cex=0.7)
plot(mymap.pro,add=TRUE)
plot(mymap.pro_lakes,add=TRUE)
```

#Compare the two products
```{r,message=FALSE}
rASC<-asc.from.raster(r.NED)
spdf<-asc2spixdf(rASC)
proj4string(spdf)<-pro

var.Q<-subset(obs.subset,select=REH1.Q)
sat.var<-over(var.Q,spdf)

n<-names(sat.var)
diff<-sat.var[n]-var.Q$REH1.Q

plot(r.NED,col=kleur.cols,breaks=kleur.breaks,main=paste("Datum=",time),legend=F)
plot(obs.subset,bg=(kleur.cols[kleur.data]),
     col="darkgrey",pch=21,add=TRUE)
text(obs.subset$DS_LON,obs.subset$DS_LAT,round(obs.subset$REH1.Q,0),pos=3,cex=0.7)
text(obs.subset$DS_LON,obs.subset$DS_LAT,round(diff[[n]],0),pos=1,cex=0.7,col="red")
plot(mymap.pro,add=TRUE)
plot(mymap.pro_lakes,add=TRUE)
```

#Geostatistical Approach: Kriging interpolation with trend
```{r,message=FALSE}
# Kriging
blocksize = 20000
mxdkrige=Inf # maxdist Krige
# over functions
gridded(spdf)=FALSE;gridded(spdf)=TRUE;fullgrid(spdf) = TRUE
slot(slot(spdf, "grid"), "cellsize") <-rep(mean(slot(slot(spdf, "grid"), "cellsize")), 2)
  # over Distshore on Var
  distshore.ov=over(obs.subset,spdf)
   # Copy the values to Var )

  var = obs.subset


  var$var=distshore.ov$var

  #Prepare input  
  field = spdf
  field@data = cbind(field@data, coordinates(field))
  names(field@data) = c("s","x","y")
  #field$log = log(field$s) 
#for(fieldlog in field$s) {try(print(paste("log of", fieldlog, "=", log(fieldlog))))}

#field$log=fieldlog
  var$x = over(var,field)$x 
  var$y = over(var,field)$y
  var$s = over(var,field)$s
  
  # Remove nodata from dataframe based on missing distshore
  var = var[!is.na(var$var),]
 
  
    ked_exp <- autoKrige(REH1.Q~var, var, spdf,maxdist=mxdkrige, block=c(blocksize,blocksize), model = c("Exp"), na.action=na.pass, fix.values=c(NA,NA,NA), miscFitOptions = list(merge.small.bins = TRUE))  #log(distshore)

# Krige Cross validation
ked_exp.cv <- autoKrige.cv(REH1.Q~var, var, model = c("Exp"),maxdist=mxdkrige,fix.values=c(NA,NA,NA), miscFitOptions = list(merge.small.bins = TRUE),verbose=c(FALSE,FALSE))
teller <- sum(ked_exp.cv$krige.cv_output$residual^2)
noemer <- sum((var$var-mean(var$var))^2)
ked_exp.r2 <- 1 - teller/noemer
ked.zscoremean <- mean(ked_exp.cv$krige.cv_output$zscore)
ked.zscore.var <- var(ked_exp.cv$krige.cv_output$zscore)

plot(ked_exp,col=kleur.cols,breaks=kleur.breaks,sp.layout=list(pts=list("sp.points",obs.subset,pch=21),mymap.pro,mymap.pro_lakes))

print(paste("R2=",round(ked_exp.r2,2)))
print(head(ked_exp$krige_output))
```

#Caret: Testing Machine Learning Models
For grid predictions with the caret package a combination of the caret::train and raster::predict functions is used. The input for the raster::predict function is either a rasterStack or rasterBrick. 

* Methods for two classes can be found [here](http://topepo.github.io/caret/train-models-by-tag.html#Two_Class_Only.html).
* Some methods of the caret package run in parallel, background information can be found [here](https://cran.r-project.org/web/packages/doParallel/vignettes/gettingstartedParallel.pdf).
* Bug in Caret "Error in e$fun(obj, substitute(ex), parent.frame(), e$data) : 
  worker initialization failed: there is no package called ‘caret’" can be fixed like [this](http://stackoverflow.com/questions/21029019/parallel-execution-of-train-in-caret-fails-with-function-not-found)
  
```{r,message=FALSE}
#cl<-makeCluster(6)
#registerDoParallel(cl)

obs.subset.Q<-subset(obs.subset,select="REH1.Q")
grid<-as(r.NED,"SpatialPixelsDataFrame")

ov<-over(obs.subset.Q,grid)
ov<-cbind(data.frame(obs.subset.Q["REH1.Q"]),ov)
ov<-rename(ov,c("DS_LON"="x"))
ov<-rename(ov,c("DS_LAT"="y"))

#m1.caret<-caret::train(REH1.Q~layer,data=ov,method="svmRadial",preProcess=c("center","scale","BoxCox"),verbose=FALSE)
m1.caret<-caret::train(REH1.Q~layer,data=ov,method="treebag",preProcess=c("center","scale","BoxCox"),verbose=FALSE)
#m1.caret<-caret::train(REH1.Q~layer,data=ov,method="rlm",preProcess=c("center","scale","BoxCox"),verbose=FALSE)

print(m1.caret)

st<-stack(grid)
p1.caret<-raster::predict(model=m1.caret,object=st)

p1.ASC<-asc.from.raster(p1.caret)
p1.spdf<-asc2spixdf(p1.ASC)
proj4string(p1.spdf)<-pro

p1.var<-over(var.Q,p1.spdf)

n<-names(p1.var)
p1.diff<-p1.var[n]-var.Q$REH1.Q

plot(p1.caret,col=kleur.cols,breaks=kleur.breaks,main=paste("Datum =",time,"\n","method = ",m1.caret$method),legend=F)
plot(obs.subset,bg=(kleur.cols[kleur.data]),
     col="darkgrey",pch=21,add=TRUE)
text(obs.subset$DS_LON,obs.subset$DS_LAT,round(obs.subset$REH1.Q,0),pos=3,cex=0.7)
text(obs.subset$DS_LON,obs.subset$DS_LAT,round(p1.diff[[n]],0),pos=1,cex=0.7,col="red")
plot(mymap.pro,add=TRUE)
plot(mymap.pro_lakes,add=TRUE)
```

#Machine learning models from the GSIF package
Note that these models require at least 50 data points for validation, as this test set is for 1 day with all KNMI observations this is not enough for a prediction. However, it is possible to make model fits. Below an example how to make ML models with GSIF. 
```{r,message=FALSE}
m1<-fit.regModel(REH1.Q~layer,rmatrix=ov,grid,method="GLM")
m2<-fit.regModel(REH1.Q~layer,rmatrix=ov,grid,method="rpart")
m3<-fit.regModel(REH1.Q~layer,rmatrix=ov,grid,method="randomForest")
#m4<-fit.regModel(REH1.Q~layer,rmatrix=ov,grid,method="quantregForest")
#m5<-fit.regModel(REH1.Q~layer,rmatrix=ov,grid,method="lme")
m6<-fit.regModel(REH1.Q~layer,rmatrix=ov,grid,method="ranger")

sppoints<-ov
coordinates(sppoints)<-~x+y
spdfpoints<-as(sppoints,"SpatialPointsDataFrame")
proj4string(spdfpoints)<-pro


#m7<-fit.gstatModel(spdfpoints,REH1.Q~layer,grid,family=gaussian(log)) #does not find a fit

#om.rk<-predict(m7,grid) #Validation data critically small (<50) for reliable validation

plot(m3)
plot(m6)
```

