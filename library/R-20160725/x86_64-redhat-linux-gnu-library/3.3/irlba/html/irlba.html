<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Find a few approximate largest singular values and...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for irlba {irlba}"><tr><td>irlba {irlba}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Find a few approximate largest singular values and corresponding
singular vectors of a matrix.</h2>

<h3>Description</h3>

<p>The augmented implicitly restarted Lanczos bidiagonalization algorithm
(IRLBA) finds a few approximate largest singular values and corresponding
singular vectors of a sparse or dense matrix using a method of Baglama and
Reichel.  It is a fast and memory-efficient way to compute a partial SVD.
</p>


<h3>Usage</h3>

<pre>
irlba(A, nv = 5, nu, maxit = 1000, work = nv + 7, reorth = TRUE,
  tol = 1e-05, v = NULL, right_only = FALSE, verbose = FALSE, scale,
  center, du, ds, dv, shift, mult, fastpath = TRUE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>A</code></td>
<td>
<p>numeric real- or complex-valued matrix or real-valued sparse matrix.</p>
</td></tr>
<tr valign="top"><td><code>nv</code></td>
<td>
<p>number of right singular vectors to estimate.</p>
</td></tr>
<tr valign="top"><td><code>nu</code></td>
<td>
<p>number of left singular vectors to estimate (defaults to <code>nv</code>).</p>
</td></tr>
<tr valign="top"><td><code>maxit</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr valign="top"><td><code>work</code></td>
<td>
<p>working subspace dimension, larger values can speed convergence at the cost of more memory use.</p>
</td></tr>
<tr valign="top"><td><code>reorth</code></td>
<td>
<p>if <code>TRUE</code>, apply full reorthogonalization to both SVD bases, otherwise
only apply reorthogonalization to the right SVD basis vectors; the latter case is cheaper per
iteration but, overall, may require more iterations for convergence.</p>
</td></tr>
<tr valign="top"><td><code>tol</code></td>
<td>
<p>convergence is determined when <i>||AV - US|| &lt; tol*||A||</i>,
where the spectral norm ||A|| is approximated by the
largest estimated singular value, and U, V, S are the matrices corresponding
to the estimated left and right singular vectors, and diagonal matrix of
estimated singular values, respectively.</p>
</td></tr>
<tr valign="top"><td><code>v</code></td>
<td>
<p>optional starting vector or output from a previous run of <code>irlba</code> used
to restart the algorithm from where it left off (see the notes).</p>
</td></tr>
<tr valign="top"><td><code>right_only</code></td>
<td>
<p>logical value indicating return only the right singular vectors
(<code>TRUE</code>) or both sets of vectors (<code>FALSE</code>). The right_only option can be
cheaper to compute and use much less memory when <code>nrow(A) &gt;&gt; ncol(A)</code>.</p>
</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>
<p>logical value that when <code>TRUE</code> prints status messages during the computation.</p>
</td></tr>
<tr valign="top"><td><code>scale</code></td>
<td>
<p>optional column scaling vector whose values divide each column of <code>A</code>;
must be as long as the number of columns of <code>A</code> (see notes).</p>
</td></tr>
<tr valign="top"><td><code>center</code></td>
<td>
<p>optional column centering vector whose values are subtracted from each
column of <code>A</code>; must be as long as the number of columns of <code>A</code> and may</p>
</td></tr>
<tr valign="top"><td><code>du</code></td>
<td>
<p>DEPRECATED optional subspace deflation vector (see notes).</p>
</td></tr>
<tr valign="top"><td><code>ds</code></td>
<td>
<p>DEPRECATED optional subspace deflation scalar (see notes).</p>
</td></tr>
<tr valign="top"><td><code>dv</code></td>
<td>
<p>DEPRECATED optional subspace deflation vector (see notes).</p>
</td></tr>
<tr valign="top"><td><code>shift</code></td>
<td>
<p>optional shift value (square matrices only, see notes).</p>
</td></tr>
<tr valign="top"><td><code>mult</code></td>
<td>
<p>optional custom matrix multiplication function (default is <code>%*%</code>, see notes).</p>
</td></tr>
<tr valign="top"><td><code>fastpath</code></td>
<td>
<p>try a fast C algorithm implementation if possible; set <code>fastpath=FALSE</code> to use the reference R implementation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with entries:
</p>

<dl>
<dt>d:</dt><dd><p> max(nu, nv) approximate singular values</p>
</dd>
<dt>u:</dt><dd><p> nu approximate left singular vectors (only when right_only=FALSE)</p>
</dd>
<dt>v:</dt><dd><p> nv approximate right singular vectors</p>
</dd>
<dt>iter:</dt><dd><p> The number of Lanczos iterations carried out</p>
</dd>
<dt>mprod:</dt><dd><p> The total number of matrix vector products carried out</p>
</dd>
</dl>



<h3>Note</h3>

<p>The syntax of <code>irlba</code> partially follows <code>svd</code>, with an important
exception. The usual R <code>svd</code> function always returns a complete set of
singular values, even if the number of singular vectors <code>nu</code> or <code>nv</code>
is set less than the maximum. The <code>irlba</code> function returns a number of
estimated singular values equal to the maximum of the number of specified
singular vectors <code>nu</code> and <code>nv</code>.
</p>
<p>Use the optional <code>scale</code> parameter to implicitly scale each column of
the matrix <code>A</code> by the values in the <code>scale</code> vector, computing the
truncated SVD of the column-scaled <code>sweep(A, 2, scale, FUN=`/`)</code>, or
equivalently, <code>A %*% diag(1 / scale)</code>, without explicitly forming the
scaled matrix. <code>scale</code> must be a non-zero vector of length equal
to the number of columns of <code>A</code>.
</p>
<p>Use the optional <code>center</code> parameter to implicitly subtract the values
in the <code>center</code> vector from each column of <code>A</code>, computing the
truncated SVD of <code>sweep(A, 2, center, FUN=`-`)</code>,
without explicitly forming the centered matrix. This option may not be
used together with the general rank 1 deflation options. <code>center</code>
must be a vector of length equal to the number of columns of <code>A</code>.
This option may be used to efficiently compute principal components without
explicitly forming the centered matrix (which can, importantly, preserve
sparsity in the matrix). See the examples.
</p>
<p>The optional deflation parameters are deprecated and will be removed in
a future version. They could be used to compute the rank-one deflated
SVD of <i>A - ds*du %*% t(dv)</i>, where
<i>t(du) %*% A - ds * t(dv) == 0</i>. For
example, the triple <code>ds, du, dv</code> may be a known singular value
and corresponding singular vectors. Or <code>ds=m</code> and <code>dv</code>
and <code>du</code> represent a vector of column means of <code>A</code> and of ones,
respectively, where <code>m</code> is the number of rows of <code>A</code>.
This functionality can be effectively replaced with custom matrix
product functions.
</p>
<p>Specify an optional alternative matrix multiplication operator in the
<code>mult</code> parameter. <code>mult</code> must be a function of two arguments,
and must handle both cases where one argument is a vector and the other
a matrix. See the examples.
</p>
<p>Use the <code>v</code> option to supply a starting vector for the iterative
method. A random vector is used by default. Optionally set <code>v</code> to
the output of a previous run of <code>irlba</code> to restart the method, adding
additional singular values/vectors without recomputing the solution
subspace. See the examples.
</p>
<p>The function may generate the following warnings:
</p>

<ul>
<li><p>&quot;did not converge&ndash;results might be invalid!; try increasing maxit or fastpath=FALSE&quot; means that the algorithm didn't
converge &ndash; this is potentially a serious problem and the returned results may not be valid. <code>irlba</code>
reports a warning here instead of an error so that you can inspect whatever is returned. If this
happens, carefully heed the warning and inspect the result.
</p>
</li>
<li><p>&quot;You're computing a large percentage of total singular values, standard svd might work better!&quot;
<code>irlba</code> is designed to efficiently compute a few of the largest singular values and associated
singular vectors of a matrix. The standard <code>svd</code> function will be more efficient for computing
large numbers of singular values than <code>irlba</code>.
</p>
</li>
<li><p>&quot;convergence criterion below machine epsilon&quot; means that the product of <code>tol</code> and the
largest estimated singular value is really small and the normal convergence criterion is only
met up to round off error.
</p>
</li></ul>

<p>The function might return an error for several reasons including a situation when the starting
vector <code>v</code> is near the null space of the matrix. In that case, try a different <code>v</code>.
</p>


<h3>References</h3>

<p>Augmented Implicitly Restarted Lanczos Bidiagonalization Methods, J. Baglama and L. Reichel, SIAM J. Sci. Comput. 2005.
</p>


<h3>See Also</h3>

<p><code><a href="../../base/html/svd.html">svd</a></code>, <code><a href="../../stats/html/prcomp.html">prcomp</a></code>, <code><a href="partial_eigen.html">partial_eigen</a></code>
</p>


<h3>Examples</h3>

<pre>
set.seed(1)

A &lt;- matrix(runif(400), nrow=20)
S &lt;- irlba(A, 3)
S$d

# Compare with svd
svd(A)$d[1:3]

# Restart the algorithm to compute more singular values
# (starting with an existing solution S)
S1 &lt;- irlba(A, 5, v=S)

# Principal components (see also prcomp_irlba)
P &lt;- irlba(A, nv=1, center=colMeans(A))

# Compare with prcomp and prcomp_irlba (might vary up to sign)
cbind(P$v,
      prcomp(A)$rotation[, 1],
      prcomp_irlba(A)$rotation[, 1])

# A custom matrix multiplication function that scales the columns of A
# (cf the scale option). This function scales the columns of A to unit norm.
col_scale &lt;- sqrt(apply(A, 2, crossprod))
mult &lt;- function(x, y)
        {
          # check if x is a  vector
          if (is.vector(x))
          {
            return((x %*% y) / col_scale)
          }
          # else x is the matrix
          x %*% (y / col_scale)
        }
irlba(A, 3, mult=mult)$d

# Compare with:
irlba(A, 3, scale=col_scale)$d

# Compare with:
svd(sweep(A, 2, col_scale, FUN=`/`))$d[1:3]

</pre>

<hr /><div style="text-align: center;">[Package <em>irlba</em> version 2.1.1 <a href="00Index.html">Index</a>]</div>
</body></html>
