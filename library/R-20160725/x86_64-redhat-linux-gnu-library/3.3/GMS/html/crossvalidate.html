<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: This function performs crossvalidation in the style of...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for crossvalidate {GMS}"><tr><td>crossvalidate {GMS}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>This function performs crossvalidation in the style of krige.cv</h2>

<h3>Description</h3>

<p>In addition to supporting kriging and idw, it also supports
thin plate splines (through Tps (fields)).
</p>


<h3>Usage</h3>

<pre>
crossvalidate(formula, data, func = "doTps", ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>formula</code></td>
<td>
<p>A formula to define the dependent and the independent variables, see the documentation of krige.</p>
</td></tr>
<tr valign="top"><td><code>data</code></td>
<td>
<p>The input data, should be a spatial object which supports coordinates extracting through coordinates()</p>
</td></tr>
<tr valign="top"><td><code>func</code></td>
<td>
<p>The function which should be used for cross-validation, possibilities are &quot;krige&quot;, &quot;idw&quot;, &quot;doNearestNeighbor&quot;
and &quot;doTps&quot;.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>parameters that are passed on to 'func'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a spatial object with the class of 'data'. The format
in which the cross-validation results are presented is equal to that of krige.cv.
</p>


<h3>Note</h3>

<p>At this stage only leave-one-out cross-validation is supported. In addition, the formula supports only a limit
syntax, i.e. log(zinc) or sqrt(dist) are not possible in the formula. Instead, create a new column in the object,
e.g. meuse$log_zinc = log(meuse$zinc).
</p>


<h3>Author(s)</h3>

<p>Paul Hiemstra, <a href="mailto:p.h.hiemstra@gmail.com">p.h.hiemstra@gmail.com</a>
</p>


<h3>Examples</h3>

<pre>
data(meuse)
coordinates(meuse) = ~x+y
data(meuse.grid)
gridded(meuse.grid) = ~x+y

regres_cv = crossvalidate(zinc~dist, meuse, func = "krige", debug.level = 0)
nearestneighbor_cv = crossvalidate(zinc~1, meuse, func = "doNearestNeighbor")
idw2_cv = crossvalidate(zinc~1, meuse, func = "idw", debug.level = 0)
idw4_cv = crossvalidate(zinc~1, meuse, func = "idw", debug.level = 0, idp = 4)
idw05_cv = crossvalidate(zinc~1, meuse, func = "idw", debug.level = 0, idp = 0.5)
ked_cv = crossvalidate(zinc~dist, meuse, func = "krige",
        model = autofitVariogram(zinc~dist, meuse, model = "Ste")$var_model, debug.level = 0)
tps_cv = crossvalidate(zinc~1, meuse, func = "doTps", debug.level = 0)
tpsdist_cv = crossvalidate(zinc~dist, meuse, func = "doTps", debug.level = 0)

compare.cv(regres_cv, idw2_cv, idw4_cv, idw05_cv, tps_cv, tpsdist_cv, ked_cv)

# Use log(zinc) as dependent variable

meuse$log_zinc = log(meuse$zinc)
kedlog_cv = crossvalidate(log_zinc~dist, meuse, func = "krige",
        model = autofitVariogram(zinc~dist, meuse, model = "Ste")$var_model, debug.level = 0)

# Test if crossvalidate matches krige.cv
dum = krige.cv(zinc~dist, meuse, model = m)
all.equal(bla$residual, ked_cv$residual)

</pre>

<hr /><div style="text-align: center;">[Package <em>GMS</em> version 0.1 <a href="00Index.html">Index</a>]</div>
</body></html>
