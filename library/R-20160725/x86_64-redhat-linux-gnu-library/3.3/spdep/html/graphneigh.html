<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Graph based spatial weights</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for graphneigh {spdep}"><tr><td>graphneigh {spdep}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Graph based spatial weights</h2>

<h3>Description</h3>

<p>Functions return a graph object containing a list with the vertex
coordinates and the to and from indices defining the edges. Some/all of these functions assume that the coordinates are not exactly regularly spaced. The helper
function <code>graph2nb</code> converts a graph
object into a neighbour list. The plot functions plot the graph objects.
</p>


<h3>Usage</h3>

<pre>
gabrielneigh(coords, nnmult=3)
relativeneigh(coords, nnmult=3)

soi.graph(tri.nb, coords, quadsegs=10)
graph2nb(gob, row.names=NULL,sym=FALSE)
## S3 method for class 'Gabriel'
plot(x, show.points=FALSE, add=FALSE, linecol=par(col), ...)
## S3 method for class 'relative'
plot(x, show.points=FALSE, add=FALSE, linecol=par(col),...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>coords</code></td>
<td>
<p>matrix of region point coordinates</p>
</td></tr>
<tr valign="top"><td><code>nnmult</code></td>
<td>
<p>scaling factor for memory allocation, default 3; if higher values are required, the function will exit with an error; example below thanks to Dan Putler</p>
</td></tr>
<tr valign="top"><td><code>tri.nb</code></td>
<td>
<p>a neighbor list created from tri2nb</p>
</td></tr>
<tr valign="top"><td><code>quadsegs</code></td>
<td>
<p>number of line segments making a quarter circle buffer, see <code><a href="../../rgeos/html/gBuffer.html">gBuffer</a></code></p>
</td></tr>
</table>

<table summary="R argblock">
<tr valign="top"><td><code>gob</code></td>
<td>
<p>a graph object created from any of the graph funtions</p>
</td></tr>
<tr valign="top"><td><code>row.names</code></td>
<td>
<p>character vector of region ids to be added to the
neighbours list as attribute <code>region.id</code>, default <code>seq(1,
      nrow(x))</code></p>
</td></tr>
<tr valign="top"><td><code>sym</code></td>
<td>
<p>a logical argument indicating whether or not neighbors
should be symetric (if i-&gt;j then j-&gt;i)</p>
</td></tr>
<tr valign="top"><td><code>x</code></td>
<td>
<p>object to be plotted</p>
</td></tr>
<tr valign="top"><td><code>show.points</code></td>
<td>
<p>(logical) add points to plot</p>
</td></tr>
<tr valign="top"><td><code>add</code></td>
<td>
<p>(logical) add to existing plot</p>
</td></tr>
<tr valign="top"><td><code>linecol</code></td>
<td>
<p>edge plotting colour</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>further graphical parameters as in <code>par(..)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The graph functions produce graphs on a 2d point set that



are all subgraphs of the Delaunay triangulation. The
relative neighbor graph is defined by the relation, x and y are neighbors if
</p>
<p style="text-align: center;"><i>d(x,y) &lt;= min(max(d(x,z),d(y,z))| z in S)</i></p>

<p>where d() is the distance, S is the set of points and z is an arbitrary
point in S. The Gabriel graph is a subgraph of the delaunay
triangulation and has the relative neighbor graph as a sub-graph. The
relative neighbor graph is defined by the relation x and y are Gabriel
neighbors if
</p>
<p style="text-align: center;"><i>d(x,y) &lt;= min((d(x,z)^2 + d(y,z)^2)^1/2 |z in S)</i></p>

<p>where x,y,z and S are as before. The sphere of influence graph is
defined for a finite point set S, let <i>r_x</i> be the distance from point x
to its nearest neighbor in S, and <i>C_x</i> is the circle centered on x. Then
x and y are SOI neigbors iff <i>C_x</i> and <i>C_y</i> intersect in at
least 2 places. From 2016-05-31, Computational Geometry in C code replaced by calls to functions in <span class="pkg">RANN</span> and <span class="pkg">rgeos</span>; with a large <code>quadsegs=</code> argument, the behaviour of the function is the same, otherwise buffer intersections only closely approximate the original function.
</p>

<p>See <code><a href="card.html">card</a></code> for details of &ldquo;nb&rdquo; objects.
</p>


<h3>Value</h3>

<p>A list of class <code>Graph</code> withte following elements
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>np</code></td>
<td>
<p>number of input points</p>
</td></tr>
<tr valign="top"><td><code>from</code></td>
<td>
<p>array of origin ids</p>
</td></tr>
<tr valign="top"><td><code>to</code></td>
<td>
<p>array of destination ids</p>
</td></tr>
<tr valign="top"><td><code>nedges</code></td>
<td>
<p>number of edges in graph</p>
</td></tr>
<tr valign="top"><td><code>x</code></td>
<td>
<p>input x coordinates</p>
</td></tr>
<tr valign="top"><td><code>y</code></td>
<td>
<p>input y coordinates</p>
</td></tr>
</table>
<p>The helper functions return an <code>nb</code> object with a list of integer
vectors containing neighbour region number ids.
</p>


<h3>Author(s)</h3>

<p>Nicholas Lewin-Koh <a href="mailto:nikko@hailmail.net">nikko@hailmail.net</a></p>


<h3>References</h3>

<p>Matula, D. W. and Sokal R. R. 1980, Properties of Gabriel
graphs relevant to geographic variation research and the clustering of
points in the plane, Geographic Analysis, 12(3), pp. 205-222.
</p>
<p>Toussaint, G. T. 1980, The relative neighborhood graph of a finite
planar set, Pattern Recognition, 12(4), pp. 261-268.
</p>
<p>Kirkpatrick, D. G. and Radke, J. D. 1985, A framework for
computational morphology. In Computational Geometry,
Ed. G. T. Toussaint, North Holland.
</p>


<h3>See Also</h3>

<p><code><a href="knearneigh.html">knearneigh</a></code>, <code><a href="dnearneigh.html">dnearneigh</a></code>,
<code><a href="knn2nb.html">knn2nb</a></code>, <code><a href="card.html">card</a></code></p>


<h3>Examples</h3>

<pre>
example(columbus)
coords &lt;- coordinates(columbus)
par(mfrow=c(2,2))
col.tri.nb&lt;-tri2nb(coords)
col.gab.nb&lt;-graph2nb(gabrielneigh(coords), sym=TRUE)
col.rel.nb&lt;- graph2nb(relativeneigh(coords), sym=TRUE)
plot(columbus, border="grey")
plot(col.tri.nb,coords,add=TRUE)
title(main="Delaunay Triangulation")
plot(columbus, border="grey")
plot(col.gab.nb, coords, add=TRUE)
title(main="Gabriel Graph")
plot(columbus, border="grey")
plot(col.rel.nb, coords, add=TRUE)
title(main="Relative Neighbor Graph")
plot(columbus, border="grey")
if (require(rgeos, quietly=TRUE) &amp;&amp; require(RANN, quietly=TRUE)) {
  col.soi.nb&lt;- graph2nb(soi.graph(col.tri.nb,coords), sym=TRUE)
  plot(col.soi.nb, coords, add=TRUE)
  title(main="Sphere of Influence Graph")
}
par(mfrow=c(1,1))
dx &lt;- rep(0.25*0:4,5)
dy &lt;- c(rep(0,5),rep(0.25,5),rep(0.5,5), rep(0.75,5),rep(1,5))
m &lt;- cbind(c(dx, dx, 3+dx, 3+dx), c(dy, 3+dy, dy, 3+dy))
try(res &lt;- gabrielneigh(m))
res &lt;- gabrielneigh(m, nnmult=4)
summary(graph2nb(res))
grd &lt;- as.matrix(expand.grid(x=1:5, y=1:5)) #gridded data
r2 &lt;- gabrielneigh(grd)
set.seed(1)
grd1 &lt;- as.matrix(expand.grid(x=1:5, y=1:5)) + matrix(runif(50, .0001, .0006), nrow=25)
r3 &lt;- gabrielneigh(grd1)
opar &lt;- par(mfrow=c(1,2))
plot(r2, show=TRUE, linecol=2)
plot(r3, show=TRUE, linecol=2)
par(opar)
</pre>

<hr /><div style="text-align: center;">[Package <em>spdep</em> version 0.6-6 <a href="00Index.html">Index</a>]</div>
</body></html>
