<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Least Cost Moving Windows Calculation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for lcmw {SDMTools}"><tr><td>lcmw {SDMTools}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Least Cost Moving Windows Calculation</h2>

<h3>Description</h3>

<p>This is a moving window that for each cell returns the
minimum 'cost' based on surrounding data cells and some
dispersal distance cost.
</p>


<h3>Usage</h3>

<pre>
lcmw(mat, mw, mnc)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>mat</code></td>
<td>
<p>a matrix of values that can be based on a
raster dataset. Lower values should represent lower cost.
The matrix can be a raster of class 'asc' (adehabitat
package), 'RasterLayer' (raster package) or
'SpatialGridDataFrame' (sp package)</p>
</td></tr>
<tr valign="top"><td><code>mw</code></td>
<td>
<p>a distance-cost matrix to be applied to each
cell of 'mat'. This matrix can be dispersal costs. Lower
values should represent lower cost.</p>
</td></tr>
<tr valign="top"><td><code>mnc</code></td>
<td>
<p>an integer value representing the radius for
'mw' in number of cells.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method moves over the matrix of values, summing the
moving window cost <code>mw</code> and the matrix <code>mat</code>,
returning the minimum cost value. This was created to
estimate the least cost path through time for all cells in
a matrix (see example).
</p>


<h3>Value</h3>

<p>A matrix of values of the same dimensions and class as
input <code>mat</code>
</p>


<h3>Author(s)</h3>

<p>Jeremy VanDerWal <a href="mailto:jjvanderwal@gmail.com">jjvanderwal@gmail.com</a>
</p>


<h3>Examples</h3>

<pre>
#create a simple object of class 'asc'
tasc = as.asc(matrix(1:100,nr=10,nc=10)); print(tasc)

#show the input matrix
print(tasc[1:10,1:10])

#vary the moving windows

###no cost window of 2 cell radius
tcost = matrix(0,nr=5,nc=5); print(tcost)
out = lcmw(tasc, tcost, 2); print(out[1:10,1:10])

###no cost with a circular radius of 2
tcost = matrix(NA,nr=5,nc=5)
#populate the distances
for (y in 1:5){
    for (x in 1:5){
        tcost[y,x] = sqrt((3-y)^2 + (3-x)^2)
    }
}

#remove distance values &gt; max.num.cells
tcost[which(tcost&gt;2)]=NA

#no cost matrix
tcost1 = tcost; tcost1[is.finite(tcost1)]=1; print(tcost1)
out = lcmw(tasc, tcost1, 2); print(out[1:10,1:10])

#linear cost
tcost = tcost/2; print(tcost)
out = lcmw(tasc, tcost, 2); print(out[1:10,1:10])
</pre>

<hr /><div style="text-align: center;">[Package <em>SDMTools</em> version 1.1-221 <a href="00Index.html">Index</a>]</div>
</body></html>
