<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: LMS Quantile Regression with a Box-Cox Transformation to...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for lms.bcn {VGAM}"><tr><td>lms.bcn {VGAM}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2> LMS Quantile Regression with a Box-Cox Transformation to Normality </h2>

<h3>Description</h3>

<p>LMS quantile regression with the Box-Cox transformation
to normality.
</p>


<h3>Usage</h3>

<pre>
lms.bcn(percentiles = c(25, 50, 75), zero = c("lambda", "sigma"),
        llambda = "identitylink", lmu = "identitylink", lsigma = "loge",
        idf.mu = 4, idf.sigma = 2, ilambda = 1,
        isigma = NULL, tol0 = 0.001)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>percentiles</code></td>
<td>

<p>A numerical vector containing values between 0 and 100,
which are the quantiles.
They will be returned as &lsquo;fitted values&rsquo;.
</p>



</td></tr>
<tr valign="top"><td><code>zero</code></td>
<td>

<p>Can be an integer-valued vector specifying which
linear/additive predictors are modelled as intercepts only.
The values must be from the set {1,2,3}.
The default value usually increases the chance of successful convergence.
Setting <code>zero = NULL</code> means they all are
functions of the covariates.
For more information see <code><a href="CommonVGAMffArguments.html">CommonVGAMffArguments</a></code>.
</p>
</td></tr>
<tr valign="top"><td><code>llambda, lmu, lsigma</code></td>
<td>

<p>Parameter link functions applied to the first, second and third
linear/additive predictors.
See <code><a href="Links.html">Links</a></code> for more choices,
and <code><a href="CommonVGAMffArguments.html">CommonVGAMffArguments</a></code>.
</p>
</td></tr>
<tr valign="top"><td><code>idf.mu</code></td>
<td>

<p>Degrees of freedom for the cubic smoothing spline fit applied to
get an initial estimate of mu.
See <code><a href="vsmooth.spline.html">vsmooth.spline</a></code>.
</p>
</td></tr>
<tr valign="top"><td><code>idf.sigma</code></td>
<td>

<p>Degrees of freedom for the cubic smoothing spline fit applied to
get an initial estimate of sigma.
See <code><a href="vsmooth.spline.html">vsmooth.spline</a></code>.
This argument may be assigned <code>NULL</code> to get an initial value
using some other algorithm.
</p>
</td></tr>
<tr valign="top"><td><code>ilambda</code></td>
<td>

<p>Initial value for lambda.
If necessary, it is recycled to be a vector of length <i>n</i>
where <i>n</i> is the number of (independent) observations.
</p>
</td></tr>
<tr valign="top"><td><code>isigma</code></td>
<td>

<p>Optional initial value for sigma.
If necessary, it is recycled to be a vector of length <i>n</i>.
The default value, <code>NULL</code>, means an initial value is computed
in the <code>@initialize</code> slot of the family function.
</p>
</td></tr>
<tr valign="top"><td><code>tol0</code></td>
<td>

<p>Small positive number,
the tolerance for testing if lambda is equal to zero.
</p>
</td></tr>
</table>








<h3>Details</h3>

<p>Given a value of the covariate, this function applies
a Box-Cox transformation to the response to best obtain
normality. The parameters chosen to do this are estimated
by maximum likelihood or penalized maximum likelihood.
</p>
<p>In more detail,
the basic idea behind this method is that, for a fixed
value of <i>x</i>, a Box-Cox transformation of the response <i>Y</i>
is applied to obtain standard normality. The 3 parameters
(<i>lambda</i>, <i>mu</i>, <i>sigma</i>,
which start with the letters &ldquo;L-M-S&rdquo;
respectively, hence its name) are chosen to maximize a penalized
log-likelihood (with <code><a href="vgam.html">vgam</a></code>). Then the
appropriate quantiles of the standard normal distribution
are back-transformed onto the original scale to get the
desired quantiles.
The three parameters may vary as a smooth function of <i>x</i>.
</p>
<p>The Box-Cox power transformation here of the <i>Y</i>, given <i>x</i>, is
</p>
<p style="text-align: center;"><i>
      Z = [(Y / mu(x))^{lambda(x)} - 1] / (sigma(x) * lambda(x))</i></p>

<p>for <i>lambda(x) != 0</i>.
(The singularity at <i>lambda(x) = 0</i>
is handled by a simple function involving a logarithm.)
Then <i>Z</i> is assumed to have a standard normal distribution.
The parameter <i>sigma(x)</i> must be positive, therefore
<span class="pkg">VGAM</span> chooses
<i>eta(x)^T =
(lambda(x), mu(x), log(sigma(x)))</i>
by default.
The parameter <i>mu</i> is also positive, but while
<i>log(mu)</i> is
available, it is not the default because <i>mu</i> is
more directly interpretable.
Given the estimated linear/additive predictors, the
<i>100*alpha</i> percentile can be estimated
by inverting the Box-Cox power transformation at the
<i>100*alpha</i> percentile of the standard
normal distribution.
</p>
<p>Of the three functions, it is often a good idea to allow
<i>mu(x)</i> to be more flexible because the functions
<i>lambda(x)</i> and <i>sigma(x)</i>
usually vary more smoothly with <i>x</i>. This is somewhat
reflected in the default value for the argument <code>zero</code>,
viz. <code>zero = c(1, 3)</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"vglmff"</code> (see <code><a href="vglmff-class.html">vglmff-class</a></code>).
The object is used by modelling functions such as <code><a href="vglm.html">vglm</a></code>,
<code><a href="rrvglm.html">rrvglm</a></code>
and <code><a href="vgam.html">vgam</a></code>.
</p>


<h3>Warning </h3>

<p>The computations are not simple, therefore convergence may fail.
Set <code>trace = TRUE</code> to monitor convergence if it isn't set already.
Convergence failure will occur if, e.g., the response is bimodal
at any particular value of <i>x</i>.
In case of convergence failure, try different starting values.
Also, the estimate may diverge quickly near the solution,
in which case try prematurely
stopping the iterations by assigning <code>maxits</code> to be the iteration
number corresponding to the highest likelihood value. 
</p>
<p>One trick is to fit a simple model and use it to provide
initial values for a more complex model; see in the
examples below.
</p>


<h3>Note</h3>

<p>The response must be positive because the Box-Cox
transformation cannot handle negative values. The
LMS-Yeo-Johnson-normal method can handle both positive
and negative values.
</p>


<p>In general, the lambda and sigma functions should be more smoother
than the mean function.
Having <code>zero = 1</code>, <code>zero = 3</code> or <code>zero = c(1, 3)</code>
is often a good idea. See the example below.
</p>








<h3>Author(s)</h3>

<p> Thomas W. Yee </p>


<h3>References</h3>

<p>Cole, T. J. and Green, P. J. (1992)
Smoothing Reference Centile Curves: The LMS Method and
Penalized Likelihood.
<em>Statistics in Medicine</em>, 
<b>11</b>, 1305&ndash;1319.
</p>
<p>Green, P. J. and Silverman, B. W. (1994)
<em>Nonparametric Regression and Generalized Linear Models: A
Roughness Penalty Approach</em>,
London: Chapman &amp; Hall.
</p>
<p>Yee, T. W. (2004)
Quantile regression via vector generalized additive models.
<em>Statistics in Medicine</em>,
<b>23</b>, 2295&ndash;2315.
</p>





<h3>See Also</h3>

<p><code><a href="lms.bcg.html">lms.bcg</a></code>,
<code><a href="lms.yjn.html">lms.yjn</a></code>,
<code><a href="qtplot.lmscreg.html">qtplot.lmscreg</a></code>,
<code><a href="deplot.lmscreg.html">deplot.lmscreg</a></code>,
<code><a href="cdf.lmscreg.html">cdf.lmscreg</a></code>,
<code><a href="alaplace3.html">alaplace1</a></code>,
<code><a href="amlnormal.html">amlnormal</a></code>,
<code><a href="enormUC.html">denorm</a></code>,
<code><a href="CommonVGAMffArguments.html">CommonVGAMffArguments</a></code>.
</p>



<h3>Examples</h3>

<pre>
## Not run:  require("VGAMdata")
mysubset &lt;- subset(xs.nz, sex == "M" &amp; ethnicity == "Maori" &amp; study1)
mysubset &lt;- transform(mysubset, BMI = weight / height^2)
BMIdata &lt;- na.omit(mysubset)
BMIdata &lt;- subset(BMIdata, BMI &lt; 80 &amp; age &lt; 65,
                   select = c(age, BMI))  # Delete an outlier
summary(BMIdata)

fit &lt;- vgam(BMI ~ s(age, df = c(4, 2)), lms.bcn(zero = 1), data = BMIdata)

par(mfrow = c(1, 2))
plot(fit, scol = "blue", se = TRUE)  # The two centered smooths

head(predict(fit))
head(fitted(fit))
head(BMIdata)
head(cdf(fit))  # Person 46 is probably overweight, given his age
100 * colMeans(depvar(fit, drop = TRUE) &lt; fitted(fit))  # Empirical proportions

# Convergence problems? Try this trick: fit0 is a simpler model used for fit1
fit0 &lt;- vgam(BMI ~ s(age, df = 4), lms.bcn(zero = c(1, 3)), data = BMIdata)
fit1 &lt;- vgam(BMI ~ s(age, df = c(4, 2)), lms.bcn(zero = 1), data = BMIdata,
            etastart = predict(fit0))

## End(Not run)

## Not run: 
# Quantile plot
par(bty = "l", mar = c(5, 4, 4, 3) + 0.1, xpd = TRUE)
qtplot(fit, percentiles = c(5, 50, 90, 99), main = "Quantiles",
       xlim = c(15, 66), las = 1, ylab = "BMI", lwd = 2, lcol = 4)

# Density plot
ygrid &lt;- seq(15, 43, len = 100)  # BMI ranges
par(mfrow = c(1, 1), lwd = 2)
(aa &lt;- deplot(fit, x0 = 20, y = ygrid, xlab = "BMI", col = "black",
  main = "Density functions at Age = 20 (black), 42 (red) and 55 (blue)"))
aa &lt;- deplot(fit, x0 = 42, y = ygrid, add = TRUE, llty = 2, col = "red")
aa &lt;- deplot(fit, x0 = 55, y = ygrid, add = TRUE, llty = 4, col = "blue",
             Attach = TRUE)
aa@post$deplot  # Contains density function values

## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>VGAM</em> version 1.0-2 <a href="00Index.html">Index</a>]</div>
</body></html>
