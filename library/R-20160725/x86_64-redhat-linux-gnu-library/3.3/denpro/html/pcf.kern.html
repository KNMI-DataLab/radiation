<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Computes a multivariate kernel estimate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for pcf.kern {denpro}"><tr><td>pcf.kern {denpro}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>
Computes a multivariate kernel estimate
</h2>

<h3>Description</h3>

<p>Computes a multivariate kernel estimate and gives the output as a piecewise
constant function object.
</p>


<h3>Usage</h3>

<pre>
pcf.kern(dendat, h, N, kernel = "gauss", weights = NULL, support = NULL,
lowest = 0, radi = 0)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>dendat</code></td>
<td>
<p>n*d matrix of real numbers; the data matrix</p>
</td></tr>
<tr valign="top"><td><code>h</code></td>
<td>
<p>d vector of positive real numbers; vector of smoothing parameters</p>
</td></tr>
<tr valign="top"><td><code>N</code></td>
<td>
<p>vector of d positive dyadic integers; 
the dimension of the grid where the
kernel estimate will be evaluated; we evaluate the estimate on a regular
grid which contains the support of the kernel estimate</p>
</td></tr>
<tr valign="top"><td><code>kernel</code></td>
<td>
<p>&quot;gauss&quot;, &quot;epane&quot;, &quot;bart&quot;, or &quot;uniform&quot;; 
the kernel is either the standard Gaussian,
Epanechnikov product kernel, Bartlett kernel, or uniform kernel</p>
</td></tr>
<tr valign="top"><td><code>weights</code></td>
<td>
<p>n vector of nonnegative weights, where n is the sample size;
sum of the elements of &quot;weights&quot; should be one;
these are the weights of a time localized kernel estimator</p>
</td></tr>
<tr valign="top"><td><code>support</code></td>
<td>
<p>2*d vector of reals gives the d intervals of a 
rectangular support in the form c(low1,upp1,...,lowd,uppd)</p>
</td></tr>
<tr valign="top"><td><code>lowest</code></td>
<td>
<p>a real value; the density estimate will be truncated to take
value zero, if the value of the estimate is less or equal to &quot;lowest&quot;</p>
</td></tr>
<tr valign="top"><td><code>radi</code></td>
<td>
<p>a nonnegative real number; the support is estimated as the smallest 
rectangle containing the observations with an additional band whose
width is equal to &quot;radi&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a piecewise constant function object, see the web site
</p>


<h3>Author(s)</h3>

<p>Jussi Klemela</p>


<h3>References</h3>

<p>http://www.rni.helsinki.fi/~jsk/denpro/</p>


<h3>See Also</h3>

<p><code><a href="draw.pcf.html">draw.pcf</a></code>
<code><a href="lstseq.kern.html">lstseq.kern</a></code>
</p>


<h3>Examples</h3>

<pre>
n&lt;-100
dendat&lt;-sim.data(n=n,type="mulmod")

h&lt;-1
pcf&lt;-pcf.kern(dendat,h=h,N=c(32,32))
dp&lt;-draw.pcf(pcf)
contour(dp$x,dp$y,dp$z,drawlabels=FALSE)

d&lt;-2
h&lt;-(4/(d+2))^(1/(d+4))*n^(-1/(d+4))*apply(dendat,2,sd)
pcf&lt;-pcf.kern(dendat,h=h,N=c(32,32))
dp&lt;-draw.pcf(pcf)
contour(dp$x,dp$y,dp$z,drawlabels=FALSE)

# we use now nonuniform weighting of kernels

weights&lt;-matrix(0,n,1)
threshold&lt;-4
for (i in 1:n){
    eta&lt;-(n-i)
    if (eta/h&gt;threshold) result&lt;-0 else result&lt;-exp(-eta^2/(2*h^2))
    weights[i]&lt;-result
}
weights&lt;-weights/sum(weights)

pcf&lt;-pcf.kern(dendat,h=1,N=c(32,32),weights=weights)

dp&lt;-draw.pcf(pcf)
contour(dp$x,dp$y,dp$z,drawlabels=FALSE)

</pre>

<hr /><div style="text-align: center;">[Package <em>denpro</em> version 0.9.2 <a href="00Index.html">Index</a>]</div>
</body></html>
