<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Apply a function to soil profiles within a...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for profileApply-methods {aqp}"><tr><td>profileApply-methods {aqp}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Apply a function to soil profiles within a SoilProfileCollection object.</h2>

<h3>Description</h3>

<p>Apply a function to soil profiles within a SoilProfileCollection object, each iteration has access to a SoilProfileCollection object.</p>


<h3>Usage</h3>

<pre>
# method for SoilProfileCollection objects
profileApply(object, FUN, simplify=TRUE, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>object</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr valign="top"><td><code>FUN</code></td>
<td>
<p>a function to be applied to each profile within the collection</p>
</td></tr>
<tr valign="top"><td><code>simplify</code></td>
<td>
<p>logical, should the result be simplified to a vector? see examples</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>further arguments passsed to FUN</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When simplify is TRUE, a vector of length <code>nrow(object)</code> (horizon data) or of length <code>length(object)</code> (site data). When simplify is FALSE, a list is returned.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "SoilProfileCollection")</code></dt><dd></dd>
</dl>


<h3>See Also</h3>

 <p><code><a href="SPC-slab-methods.html">slab</a></code>, <code><a href="estimateSoilDepth.html">estimateSoilDepth</a></code></p>


<h3>Examples</h3>

<pre>
data(sp1)
depths(sp1) &lt;- id ~ top + bottom

# estimate soil depth using horizon designations
profileApply(sp1, estimateSoilDepth, name='name', top='top', bottom='bottom')

# scale properties within each profile
# scaled = (x - mean(x)) / sd(x)
sp1$d &lt;- profileApply(sp1, FUN=function(x) round(scale(x$prop), 2))
plot(sp1, name='d')


# compute depth-wise differencing by profile
# note that our function expects that the column 'prop' exists
f &lt;- function(x) { c(x$prop[1], diff(x$prop)) }
sp1$d &lt;- profileApply(sp1, FUN=f)
plot(sp1, name='d')

# compute depth-wise cumulative sum by profile
# note the use of an anonymous function
sp1$d &lt;- profileApply(sp1, FUN=function(x) cumsum(x$prop))
plot(sp1, name='d')


# compute profile-means, and save to @site
# there must be some data in @site for this to work
site(sp1) &lt;- ~ group
sp1$mean_prop &lt;- profileApply(sp1, FUN=function(x) mean(x$prop, na.rm=TRUE))

# re-plot using ranks defined by computed summaries (in @site)
plot(sp1, plot.order=rank(sp1$mean_prop))


## iterate over profiles, subsetting horizon data

# example data
data(sp1)

# promote to SoilProfileCollection
depths(sp1) &lt;- id ~ top + bottom
site(sp1) &lt;- ~ group

# make some fake site data related to a depth of some importance
sp1$dep &lt;- profileApply(sp1, function(i) {round(rnorm(n=1, mean=mean(i$top)))})

# custom function for subsetting horizon data, by profile
# keep horizons with lower boundary &lt; site-level attribute 'dep'
fun &lt;- function(i) {
  # extract horizons
  h &lt;- horizons(i)
  # make an expression to subset horizons
  exp &lt;- paste('bottom &lt; ', i$dep, sep='')
  # subset horizons, and write-back into current SPC
  horizons(i) &lt;- subset(h, subset=eval(parse(text=exp)))
  # return modified SPC
  return(i)
}

# list of modified SoilProfileCollection objects
l &lt;- profileApply(sp1, fun, simplify=FALSE)

# re-combine list of SoilProfileCollection objects into a single SoilProfileCollection
sp1.sub &lt;- do.call(rbind, l)

# graphically check
par(mfrow=c(2,1), mar=c(0,0,1,0))
plot(sp1)
points(1:length(sp1), sp1$dep, col='red', pch=7)
plot(sp1.sub)


## Not run: 
##
## helper functions: these must be modified to suit your own data
##

# compute the weighted-mean of some property within a given diagnostic horizon
# note that this requires conditional eval of data that may contain NA
# see ?slab for details on the syntax
# note that function expects certain columns within 'x'
f.diag.wt.prop &lt;- function(x, d.hz, prop) {
  # extract diagnostic horizon data
  d &lt;- diagnostic_hz(x)
  # subset to the requested diagnostic hz
  d &lt;- d[d$diag_kind == d.hz, ]
  # if missing return NA
  if(nrow(d) == 0)
    return(NA)
  
  # extract depths and check for missing
  sv &lt;- c(d$featdept, d$featdepb)
  if(any(is.na(sv)))
    return(NA)
  
  # create formula from named property
  fm &lt;- as.formula(paste('~', prop))
  # return just the (weighted) mean, accessed from @horizons
  s &lt;- slab(x, fm, slab.structure=sv, slab.fun=mean)$value
  return(s)
}


# conditional eval of thickness of some diagnostic feature or horizon
# will return a vector of length(x), you can save to @site
f.diag.thickness &lt;- function(x, d.hz) {
  # extract diagnostic horizon data
  d &lt;- diagnostic_hz(x)
  # subset to the requested diagnostic hz
  d &lt;- d[d$diag_kind == d.hz, ]
  # if missing return NA
  if(nrow(d) == 0)
    return(NA)
  
  # compute thickness
  thick &lt;- d$featdepb - d$featdept
  return(thick)
}


# conditional eval of property within particle size control section
# makes assumptions about the SPC that is passed-in
f.psc.prop &lt;- function(x, prop) {
  # these are accessed from @site
  sv &lt;- c(x$psctopdepth, x$pscbotdepth)
  # test for missing PCS data
  if(any(is.na(sv)))
    return(NA) 
  
  # this should never happen... unless someone made a mistake
  # check to make sure that the lower PSC boundary is shallower than the depth
  if(sv[2] &gt; max(x))
    return(NA)
  
  # create formula from named property
  fm &lt;- as.formula(paste('~', prop))
  # return just the (weighted) mean, accessed from @horizons
  s &lt;- slab(x, fm, slab.structure=sv, slab.fun=mean)$value
  return(s)
}

# try with some sample data
data(loafercreek, package='soilDB')

profileApply(loafercreek, f.diag.wt.prop, d.hz='argillic horizon', prop='clay')
profileApply(loafercreek, f.diag.thickness, d.hz='argillic horizon')
profileApply(loafercreek, f.psc.prop, prop='clay')


## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>aqp</em> version 1.9.3 <a href="00Index.html">Index</a>]</div>
</body></html>
