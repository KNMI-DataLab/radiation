<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Method caller for SnnsR objects</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for SnnsRObjectMethodCaller {RSNNS}"><tr><td>SnnsRObjectMethodCaller {RSNNS}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Method caller for SnnsR objects</h2>

<h3>Description</h3>

<p>Enable calling of C++ functions as methods of <code>SnnsR-class</code> objects.
</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'SnnsR'
x$name
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>object of class <a href="SnnsR-class.html">SnnsR-class</a></p>
</td></tr>
<tr valign="top"><td><code>name</code></td>
<td>
<p>function to call</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes methods of SnnsR__ and SnnsCLib__ accessible via &quot;$&quot;. If
no SnnsR__ method is present, then the according SnnsCLib__ method is
called. This enables a very flexible method handling. To mask a method from
SnnsCLib, e.g. to do some parameter checking or postprocessing, only a method
with the same name, but beginning with SnnsR__ has to be present in R.  See
e.g. <code><a href="SnnsRObject-initializeNet.html">SnnsRObject$initializeNet</a></code> for such an implementation.
</p>
<p>Error handling is also done within the method caller. If the result of a
function is a list with a member <code>err</code>,  then <code>SnnsCLib__error</code> is
called to use the SNNS kernel function to get the corresponding error message
code and an R warning is thrown containing this message.
</p>
<p>Furthermore, a serialization mechanism is implemented which all models
present in the package use to be able to be saved and loaded by R's normal
save/load mechanism (as RData files).
</p>
<p>The completely trained object can be serialized with
</p>
<p><code>s &lt;- snnsObject$serializeNet("RSNNS_untitled")</code>
</p>
<p><code>snnsObject@variables$serialization &lt;- s$serialization</code>
</p>
<p>For the models implemented, this is done in <code><a href="SnnsRObject-train.html">SnnsRObject$train</a></code>. If the S4 object is then saved and loaded,
the calling mechanism will notice on the next use of a function that the pointer to the C++ SnnsCLib object is <code>nil</code>,
and if a serialization is present, the object is restored from this serialization before the method is called.
</p>

<hr /><div style="text-align: center;">[Package <em>RSNNS</em> version 0.4-7 <a href="00Index.html">Index</a>]</div>
</body></html>
