<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Scaling</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for gdk-pixbuf-scaling {RGtk2}"><tr><td>gdk-pixbuf-scaling {RGtk2}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Scaling</h2>

<h3>Description</h3>

<p>Scaling pixbufs and scaling and compositing pixbufs</p>


<h3>Methods and Functions</h3>

<p><code><a href="gdkPixbufScaleSimple.html">gdkPixbufScaleSimple</a>(object, dest.width, dest.height, interp.type)</code><br />
<code><a href="gdkPixbufScale.html">gdkPixbufScale</a>(object, dest, dest.x, dest.y, dest.width, dest.height, offset.x, offset.y, scale.x, scale.y, interp.type)</code><br />
<code><a href="gdkPixbufCompositeColorSimple.html">gdkPixbufCompositeColorSimple</a>(object, dest.width, dest.height, interp.type, overall.alpha, check.size, color1, color2)</code><br />
<code><a href="gdkPixbufComposite.html">gdkPixbufComposite</a>(object, dest, dest.x, dest.y, dest.width, dest.height, offset.x, offset.y, scale.x, scale.y, interp.type, overall.alpha)</code><br />
<code><a href="gdkPixbufCompositeColor.html">gdkPixbufCompositeColor</a>(object, dest, dest.x, dest.y, dest.width, dest.height, offset.x, offset.y, scale.x, scale.y, interp.type, overall.alpha, check.x, check.y, check.size, color1, color2)</code><br />
<code><a href="gdkPixbufRotateSimple.html">gdkPixbufRotateSimple</a>(object, angle)</code><br />
<code><a href="gdkPixbufFlip.html">gdkPixbufFlip</a>(object, horizontal)</code><br />
</p>


<h3>Detailed Description</h3>

<p>    The <code>gdk-pixbuf</code> contains functions to scale pixbufs, to scale
pixbufs and composite against an existing image, and to scale
pixbufs and composite against a solid color or checkerboard.
Compositing a checkerboard is a common way to show an image with
an alpha channel in image-viewing and editing software.
</p>
<p>Since the full-featured functions (<code><a href="gdkPixbufScale.html">gdkPixbufScale</a></code>,
<code><a href="gdkPixbufComposite.html">gdkPixbufComposite</a></code>, and <code><a href="gdkPixbufCompositeColor.html">gdkPixbufCompositeColor</a></code>) are
rather complex to use and have many arguments, two simple
convenience functions are provided, <code><a href="gdkPixbufScaleSimple.html">gdkPixbufScaleSimple</a></code> and
<code><a href="gdkPixbufCompositeColorSimple.html">gdkPixbufCompositeColorSimple</a></code> which create a new pixbuf of a
given size, scale an original image to fit, and then return the
new pixbuf.
</p>
<p>Scaling and compositing functions take advantage of MMX hardware
acceleration on systems where MMX is supported.  If gdk-pixbuf is built
with the Sun mediaLib library, these functions are instead accelerated
using mediaLib, which provides hardware acceleration on Intel, AMD,
and Sparc chipsets.  If desired, mediaLib support can be turned off by
setting the GDK_DISABLE_MEDIALIB environment variable.
</p>
<p>The following example demonstrates handling an expose event by
rendering the appropriate area of a source image (which is scaled
to fit the widget) onto the widget's window.  The source image is
rendered against a checkerboard, which provides a visual
representation of the alpha channel if the image has one. If the
image doesn't have an alpha channel, calling
<code><a href="gdkPixbufCompositeColor.html">gdkPixbufCompositeColor</a></code> function has exactly the same effect
as calling <code><a href="gdkPixbufScale.html">gdkPixbufScale</a></code>.
</p>
<p><em>Handling an expose event.</em>
</p>
<pre>
expose_cb &lt;- function(widget, event, data)
{
  dest &lt;- gdkPixbuf(color = "rgb", has.alpha = FALSE, bits = 8, 
                    w = event[["area"]]$width, h = event[["area"]]$height)

  area &lt;- event[["area"]]
  pixbuf$compositeColor(dest, 0, 0, area$width, area$height,
                        -area$x, -area$y,
                        widget[["allocation"]]$width / pixbuf$getWidth(),
                        widget[["allocation"]]$height / pixbuf$getHeight(),
                        "bilinear", 255,
                        area$x, area$y, 16, 0xaaaaaa, 0x555555)

  dest$renderToDrawable(widget[["window"]],
                        widget[["style"]][["fgGc"]][[GtkStateType["normal"]+1]],
                        0, 0, area$x, area$y,
                        area$width, area$height,
                        "normal", area$x, area$y)

  return(TRUE)
}
</pre>

<h3>Enums and Flags</h3>


<dl>
<dt><code style="white-space: pre;">GdkInterpType</code></dt><dd>
<p>This enumeration describes the different interpolation modes that
can be used with the scaling functions. <code>GDK.INTERP.NEAREST</code> is
the fastest scaling method, but has horrible quality when
scaling down. <code>GDK.INTERP.BILINEAR</code> is the best choice if you
aren't sure what to choose, it has a good speed/quality balance.
<strong>PLEASE NOTE:</strong> 	Cubic filtering is missing from the list; hyperbolic
interpolation is just as fast and results in higher quality.
</p>

<dl>
<dt><code style="white-space: pre;">nearest</code></dt><dd><p>Nearest neighbor sampling; this is the fastest
and lowest quality mode. Quality is normally unacceptable when scaling
down, but may be OK when scaling up.</p>
</dd>
<dt><code style="white-space: pre;">tiles</code></dt><dd><p>This is an accurate simulation of the PostScript
image operator without any interpolation enabled.  Each pixel is
rendered as a tiny parallelogram of solid color, the edges of which
are implemented with antialiasing.  It resembles nearest neighbor for
enlargement, and bilinear for reduction.</p>
</dd>
<dt><code style="white-space: pre;">bilinear</code></dt><dd><p>Best quality/speed balance; use this mode by
default. Bilinear interpolation.  For enlargement, it is
equivalent to point-sampling the ideal bilinear-interpolated image.
For reduction, it is equivalent to laying down small tiles and
integrating over the coverage area.</p>
</dd>
<dt><code style="white-space: pre;">hyper</code></dt><dd><p>This is the slowest and highest quality
reconstruction function. It is derived from the hyperbolic filters in
Wolberg's &quot;Digital Image Warping&quot;, and is formally defined as the
hyperbolic-filter sampling the ideal hyperbolic-filter interpolated
image (the filter is designed to be idempotent for 1:1 pixel mapping).</p>
</dd>
</dl>

</dd>
<dt><code style="white-space: pre;">GdkPixbufRotation</code></dt><dd>
<p>The possible rotations which can be passed to <code><a href="gdkPixbufRotateSimple.html">gdkPixbufRotateSimple</a></code>.
To make them easier to use, their numerical values are the actual degrees.
</p>

<dl>
<dt><code style="white-space: pre;">none</code></dt><dd><p>No rotation.</p>
</dd>
<dt><code style="white-space: pre;">counterclockwise</code></dt><dd><p>Rotate by 90 degrees.</p>
</dd>
<dt><code style="white-space: pre;">upsidedown</code></dt><dd><p>Rotate by 180 degrees.</p>
</dd>
<dt><code style="white-space: pre;">clockwise</code></dt><dd><p>Rotate by 270 degrees.</p>
</dd>
</dl>

</dd>
</dl>


<h3>Author(s)</h3>

<p>Derived by RGtkGen from GTK+ documentation</p>


<h3>References</h3>

<p><a href="http://library.gnome.org/devel//gdk-pixbuf/gdk-pixbuf-scaling.html">http://library.gnome.org/devel//gdk-pixbuf/gdk-pixbuf-scaling.html</a></p>

<hr /><div style="text-align: center;">[Package <em>RGtk2</em> version 2.20.31 <a href="00Index.html">Index</a>]</div>
</body></html>
