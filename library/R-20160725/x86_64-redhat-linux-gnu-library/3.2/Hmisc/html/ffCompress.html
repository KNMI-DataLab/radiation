<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Transform Data Frame Into a Compact 'ff' Object</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for ffCompress {Hmisc}"><tr><td>ffCompress {Hmisc}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Transform Data Frame Into a Compact <code>ff</code> Object</h2>

<h3>Description</h3>

<p>The <code>ff</code> package implements a wide variety of atomic data types
down to 2 bits, allowing for compact storage of large datasets and
requiring memory usage in R for only those rows and columns of the
dataset that are needed at one time.  It is best to create a compact
<code>ffdf</code> data frame object while initially reading the external
data file, using for example an input <code>.csv</code> file and specifying
the <code>ff</code> <code>vmode</code>s for all the columns.  If you can get
enough memory to read the entire dataset into an R <code>data.frame</code>
you can use <code>ffCompress</code> after the fact to analyze the data frame
and use the most compact data representation possible.  This entails
using single precision for floating point numbers (which can be easily
overridden to use R's usual double precision) and a variety of integer
types depend on the number of bits used by the maximum absolute value
of the variable, whether or not <code>NA</code>s exist in the data, and
whether or not negative values are possible.
</p>
<p>Since <code>ff</code> does not allow variable labels and units, any such
attributes are stripped off of variables and stored as attributes on the
entire <code>ffdf</code> object.  An <code>as.data.frame</code> and subscripting
method retrieves these attributes and restores them to individual
variables when needed.
</p>


<h3>Usage</h3>

<pre>
ffCompress(obj, float=c('single', 'double'), print=FALSE)

## S3 method for class 'ffdflabel'
as.data.frame(x, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>obj</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr valign="top"><td><code>float</code></td>
<td>
<p>representation to use for floating point vectors.  The
default is single precision (4 bytes, 7 significant digits).
Specify <code>float='double'</code> to use double precision (8 bytes, 15
significant digits)</p>
</td></tr>
<tr valign="top"><td><code>print</code></td>
<td>
<p>set to <code>TRUE</code> to get progress output and passed as
the <code>VERBOSE</code> argument to <code>ff</code> functions</p>
</td></tr>
<tr valign="top"><td><code>x</code></td>
<td>
<p>an <code>ffdf</code> object</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>ffdf</code> object for <code>ffCompress</code>, a <code>data.frame</code> for
<code>as.data.frame</code>, and either one of these for subscripting.  If
subscripting results in a single variable and <code>drop=FALSE</code> is not
specified, the result is of <code>ff</code> type.
</p>


<h3>Author(s)</h3>

<p>Frank Harrell, Vanderbilt University</p>


<h3>See Also</h3>

<p><code><a href="cleanup.import.html">cleanup.import</a></code></p>


<h3>Examples</h3>

<pre>
## Not run: 
require(ff)
require(survival)
n &lt;- 1e6
d &lt;- data.frame(x=rnorm(n), y=sample(0:1, n, TRUE),
                i=as.Date('2013-01-02'), S=Surv(runif(n)),
                z=factor(sample(1:3, n, TRUE), 1:3,
                  c('elephant','giraffe','dog')))
## Cannot have labels for variables; ff will reject as non-atomic vectors
storage.mode(d$y)
object.size(d)
n * (8 + 4 + 4 + 4)
f &lt;- as.ffdf(d, vmode=c('single', 'quad', 'integer', 'single', 'quad'))
vmode(f)
n * (4 + 0.25 + 4 + 0.25)
object.size(as.data.frame(f))
f[1:10,]
hist(d[,'x'] - f[,'x'], nclass=100)
table(d[,'z'], f[,'z'])

system.time(subset(f, z == 'dog'))
system.time({i &lt;- ffwhich(f, z == 'dog'); f[i,]})
table(subset(f, z == 'dog')[,'z'])
class(subset(f, z == 'dog'))

ffsave(f, file='/tmp/f')  # creates /tmp/f.ffData /tmp/f.RData
## To load: ffload('/tmp/f')

d &lt;- upData(d, labels=c(y='Y'), units=c(z='units z'))
f &lt;- ffCompress(d)
vmode(f)

load('ras.rda')   # dataset is not available
r &lt;- ffCompress(ras)
vmode(r)
attr(r, 'label')
attr(r, 'units')
all.equal(ras, as.data.frame(r))
dr &lt;- as.data.frame(r)
g &lt;- function(x) names(attributes(x))
nam &lt;- names(dr)
for(i in 1 : ncol(dr)) {
  a &lt;- ras[[i]]
  b &lt;- dr[[i]]
  cat(nam[i], '\n')
  cat(g(a), '\n', g(b), '\n')
  cat(max(w &lt;- abs(unclass(a) - unclass(b)), na.rm=TRUE), '\n')
  if(nam[i] == 'ldl') {
    j &lt;- which.max(abs(w))
    cat(a[j], b[j], '\n')
  }
}

dr &lt;- as.data.frame(r)
xless(contents(dr))
xless(contents(r[1:10,]))
xless(contents(r[,1:10]))

table(r[, 'gender'])
## subset invokes [] so uses method from ffdflabel
m &lt;- subset(r, gender == 'Male')
class(m)
dim(m)
attr(m, 'label')
attributes(m[,'age'])
df &lt;- as.data.frame(m)
class(df$age)
label(df$age)
## But if subset again things are not OK
k &lt;- subset(m, age &lt; 3)
class(k)
contents(k[, 'age', drop=FALSE])
invisible(ffsave(r, file='/tmp/r'))

## w &lt;- read.csv.ffdf(file='/tmp/data.csv', first.rows=10000)
## table(vmode(w))

## From ff manual:  vmode definitions
# boolean 1 bit logical without NA
# logical 2 bit logical with NA
# quad 2 bit unsigned integer without NA
# nibble 4 bit unsigned integer without NA
# byte 8 bit signed integer with NA
# ubyte 8 bit unsigned integer without NA
# short 16 bit signed integer with NA
# ushort 16 bit unsigned integer without NA
# integer 32 bit signed integer with NA
# single 32 bit float
# double 64 bit float
# complex 2x64 bit float
# raw 8 bit unsigned char
# character character

## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>Hmisc</em> version 3.17-4 <a href="00Index.html">Index</a>]</div>
</body></html>
