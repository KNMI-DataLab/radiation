<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Determine ML Horizon Boundaries</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for get.ml.hz {aqp}"><tr><td>get.ml.hz {aqp}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Determine ML Horizon Boundaries</h2>

<h3>Description</h3>

<p>This function accepts input from <code>slab()</code> along with a vector of horizon names, and returns a <code>data.frame</code> of the most likely horizon boundaries.</p>


<h3>Usage</h3>

<pre>
get.ml.hz(x, o.names)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>output from <code><a href="SPC-slab-methods.html">slab</a></code></p>
</td></tr>
<tr valign="top"><td><code>o.names</code></td>
<td>
<p>an optional character vector of horizon designations that will be used in the final table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is expecting that <code>x</code> is a data.frame generated by <code><a href="SPC-slab-methods.html">slab</a></code>. If <code>x</code> was not generated by <code>slab</code>, then <code>o.names</code> is required.</p>


<h3>Value</h3>

<p>A dataframe with the following columns:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>hz</code></td>
<td>
<p>horizon names</p>
</td></tr>
<tr valign="top"><td><code>top</code></td>
<td>
<p>top boundary</p>
</td></tr>
<tr valign="top"><td><code>bottom</code></td>
<td>
<p>bottom boundary</p>
</td></tr>
<tr valign="top"><td><code>confidence</code></td>
<td>
<p>integrated probability / ML horizon thickness, rounded to the nearest integer</p>
</td></tr>
<tr valign="top"><td><code>pseudo.brier</code></td>
<td>
<p>A &quot;pseudo&quot;&quot; Brier Score for a multi-class prediction, where the most-likely horizon label is treated as the &quot;correct&quot; outcome. Details on the calculation for traditional Brier Scores here: <a href="http://en.wikipedia.org/wiki/Brier_score#Original_definition_by_Brier">http://en.wikipedia.org/wiki/Brier_score#Original_definition_by_Brier</a>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>D.E. Beaudette</p>


<h3>See Also</h3>

<p><code><a href="SPC-slab-methods.html">slab</a></code></p>


<h3>Examples</h3>

<pre>
data(sp1)
depths(sp1) &lt;- id ~ top + bottom

# normalize horizon names: result is a factor
sp1$name &lt;- generalize.hz(sp1$name, 
  new=c('O','A','B','C'), 
  pat=c('O', '^A','^B','C'))

# compute slice-wise probability so that it sums to contributing fraction, from 0-150
a &lt;- slab(sp1, fm= ~ name, cpm=1, slab.structure=0:150)

# generate table of ML horizonation
get.ml.hz(a, o.names=c('O','A','B','C'))
</pre>

<hr /><div style="text-align: center;">[Package <em>aqp</em> version 1.9.10 <a href="00Index.html">Index</a>]</div>
</body></html>
