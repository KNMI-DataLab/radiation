<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Positive Bernoulli Family Function with Time and Behavioural...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for posbernoulli.tb {VGAM}"><tr><td>posbernoulli.tb {VGAM}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2> Positive Bernoulli Family Function with Time and Behavioural Effects </h2>

<h3>Description</h3>

<p>Fits a GLM/GAM-like model to multiple
Bernoulli responses where
each row in the capture history matrix response has at least one success
(capture).
Sampling occasion effects and behavioural effects are accommodated.
</p>


<h3>Usage</h3>

<pre>
posbernoulli.tb(link = "logit", parallel.t = FALSE ~ 1,
                parallel.b = FALSE ~ 0, drop.b = FALSE ~ 1,
                type.fitted = c("likelihood.cond", "mean.uncond"),
                imethod = 1, iprob = NULL,
                p.small = 1e-4, no.warning = FALSE,
                ridge.constant = 0.01, ridge.power = -4)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>link, imethod, iprob</code></td>
<td>

<p>See <code><a href="CommonVGAMffArguments.html">CommonVGAMffArguments</a></code> for information.
</p>
</td></tr>
<tr valign="top"><td><code>parallel.t, parallel.b, drop.b</code></td>
<td>

<p>A logical, or formula with a logical as the response.
See <code><a href="CommonVGAMffArguments.html">CommonVGAMffArguments</a></code> for information.
The <code>parallel.</code>-type arguments
specify whether the constraint matrices have a parallelism
assumption for the temporal and behavioural effects.
Argument <code>parallel.t</code> means parallel with respect to time, and
matches the same argument name in <code><a href="posbernoulli.t.html">posbernoulli.t</a></code>.
</p>
<p>Suppose the model is intercept-only.
Setting <code>parallel.t = FALSE ~ 0</code> results in the <i>M_b</i> model.
Setting <code>drop.b = FALSE ~ 0</code> results in the <i>M_t</i> model
because it drops columns off the constraint matrices corresponding
to any behavioural effect.
Setting <code>parallel.t = FALSE ~ 0</code> and
setting <code>parallel.b = FALSE ~ 0</code> results in the <i>M_b</i> model.
Setting <code>parallel.t = FALSE ~ 0</code>,
<code>parallel.b = FALSE ~ 0</code> and
<code>drop.b = FALSE ~ 0</code> results in the <i>M_0</i> model.
Note the default for <code>parallel.t</code> and <code>parallel.b</code>
may be unsuitable for data sets which have a large <i>&tau;</i>
because of the large number of parameters; it might be too flexible.
If it is desired to have the behaviour affect some of
the other covariates then set <code>drop.b = TRUE ~ 0</code>.
</p>
<p>The default model has a different intercept for each
sampling occasion, a time-parallelism assumption for all other covariates,
and a dummy variable representing a
single behavioural effect (also in the intercept).
</p>
<p>The most flexible model is to set
<code>parallel.b = TRUE  ~ 0</code>,
<code>parallel.t = TRUE  ~ 0</code> and
<code>drop.b = TRUE ~ 0</code>.
This means that all possible temporal and behavioural effects are
estimated, for the intercepts and other covariates.
Such a model is <em>not</em> recommended; it will contain a lot of paramters.
</p>
</td></tr>
<tr valign="top"><td><code>type.fitted</code></td>
<td>

<p>Character, one of the choices for the type of fitted value returned.
The default is the first one.
Partial matching is okay.
For <code>"likelihood.cond"</code>:
the probability defined by the conditional likelihood.
For <code>"mean.uncond"</code>: the unconditional mean, which should
agree with <code><a href="../../base/html/colMeans.html">colMeans</a></code> applied to the response
matrix for intercept-only models.
</p>
</td></tr>
<tr valign="top"><td><code>ridge.constant, ridge.power</code></td>
<td>

<p>Determines the ridge parameters at each IRLS iteration.
They are the constant and power (exponent) for the ridge adjustment
for the working weight matrices (the capture probability block
matrix, hence the first <i>&tau;</i> diagonal values).
At iteration <i>a</i> of the IRLS algorithm
a positive value is added to the first <i>tau</i>
diagonal elements of the working weight matrices to make
them positive-definite. This adjustment is the
mean of the diagonal elements of <code>wz</code> multipled by
<i>K * a^p</i>
where <i>K</i> is <code>ridge.constant</code> and <i>p</i> is <code>ridge.power</code>.
This is always positive but decays to zero as iterations proceed
(provided <i>p</i> is negative etc.).
</p>
</td></tr>
<tr valign="top"><td><code>p.small, no.warning</code></td>
<td>

<p>See <code><a href="posbernoulli.t.html">posbernoulli.t</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This model
(commonly known as <i>M_{tb}</i>/<i>M_{tbh}</i> in the capture&ndash;recapture literature)
operates on a response matrix of 0s and 1s (<i>n x tau</i>).
See <code><a href="posbernoulli.t.html">posbernoulli.t</a></code>
for information that is in common.
It allows time and behavioural effects to be modelled.
</p>
<p>Evidently,
the expected information matrix (EIM) seems <em>not</em>
of full rank (especially in early iterations), so
<code>ridge.constant</code> and <code>ridge.power</code> are used to
<em>try</em> fix up the problem.
The default link functions
are <i>
           (logit p_{c1},&hellip;,logit p_{c,tau},logit p_{r2},&hellip;,logit p_{r,tau})^T</i>
where the subscript <i>c</i> denotes capture,
the subscript <i>r</i> denotes recapture,
and it is not possible to recapture the animal at sampling occasion 1.
Thus <i>M=2*tau-1</i>.
The parameters are currently prefixed by <code>pcapture</code> and <code>precapture</code>
for the capture and recapture probabilities.
This <span class="pkg">VGAM</span> family function may be further modified in the future.
</p>





<h3>Value</h3>

<p>An object of class <code>"vglmff"</code> (see <code><a href="vglmff-class.html">vglmff-class</a></code>).
The object is used by modelling functions such as <code><a href="vglm.html">vglm</a></code>,
and <code><a href="vgam.html">vgam</a></code>.
</p>


<h3>Note</h3>

<p>It is a good idea to apply the parallelism assumption to each sampling
occasion except possibly with respect to the intercepts.
Also, a simple behavioural effect such as being modelled using the intercept
is recommended; if the behavioural effect is not parallel and/or
allowed to apply to other covariates
then there will probably be too many parameters, and hence,
numerical problems. See <code>M_tbh.1</code> below.
</p>










<p>It is a good idea to monitor convergence.
Simpler models such as the <i>M_0</i>/<i>M_h</i> models
are best fitted with <code><a href="posbernoulli.t.html">posbernoulli.t</a></code> or
<code><a href="posbernoulli.b.html">posbernoulli.b</a></code> or
<code><a href="posbinomial.html">posbinomial</a></code>.
</p>






<h3>Author(s)</h3>

<p> Thomas W. Yee. </p>


<h3>References</h3>

<p>See <code><a href="posbernoulli.t.html">posbernoulli.t</a></code>.
</p>


<h3>See Also</h3>

 
<p><code><a href="posbernoulli.b.html">posbernoulli.b</a></code> (including <code>N.hat</code>),
<code><a href="posbernoulli.t.html">posbernoulli.t</a></code>,
<code><a href="posbinomial.html">posbinomial</a></code>,
<code><a href="Select.html">Select</a></code>,
<code><a href="fill.html">fill1</a></code>,
<code><a href="Huggins89.t1.html">Huggins89table1</a></code>,
<code><a href="Huggins89.t1.html">Huggins89.t1</a></code>,
<code><a href="deermice.html">deermice</a></code>,
<code><a href="prinia.html">prinia</a></code>.
</p>


<h3>Examples</h3>

<pre>
## Not run: 
# Example 1: simulated data
nTimePts &lt;- 5  # (aka tau == # of sampling occasions)
nnn &lt;- 1000   # Number of animals
pdata &lt;- rposbern(n = nnn, nTimePts = nTimePts, pvars = 2)
dim(pdata); head(pdata)

M_tbh.1 &lt;- vglm(cbind(y1, y2, y3, y4, y5) ~ x2,
                posbernoulli.tb, data = pdata, trace = TRUE)
coef(M_tbh.1)  # First element is the behavioural effect
coef(M_tbh.1, matrix = TRUE)
constraints(M_tbh.1, matrix = TRUE)
summary(M_tbh.1, presid = FALSE)  # Standard errors are approximate
head(fitted(M_tbh.1))
head(model.matrix(M_tbh.1, type = "vlm"), 21)
dim(depvar(M_tbh.1))

M_tbh.2 &lt;- vglm(cbind(y1, y2, y3, y4, y5) ~ x2,
                posbernoulli.tb(parallel.t = FALSE ~  0),
                data = pdata, trace = TRUE)
coef(M_tbh.2)  # First element is the behavioural effect
coef(M_tbh.2, matrix = TRUE)
constraints(M_tbh.2, matrix = TRUE)
summary(M_tbh.2, presid = FALSE)  # Standard errors are approximate
head(fitted(M_tbh.2))
head(model.matrix(M_tbh.2, type = "vlm"), 21)
dim(depvar(M_tbh.2))

# Example 2: deermice subset data
fit1 &lt;- vglm(cbind(y1, y2, y3, y4, y5, y6) ~ sex + weight,
             posbernoulli.t, data = deermice, trace = TRUE)
coef(fit1)
coef(fit1, matrix = TRUE)
constraints(fit1, matrix = TRUE)
summary(fit1, presid = FALSE)  # Standard errors are approximate

# fit1 is the same as Fit1 (a M_{th} model):
Fit1 &lt;- vglm(cbind(y1, y2, y3, y4, y5, y6) ~ sex + weight,
             posbernoulli.tb(drop.b = TRUE ~ sex + weight,
                             parallel.t = TRUE),  # No parallelism for the intercept
             data = deermice, trace = TRUE)
constraints(Fit1)

## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>VGAM</em> version 1.0-2 <a href="00Index.html">Index</a>]</div>
</body></html>
