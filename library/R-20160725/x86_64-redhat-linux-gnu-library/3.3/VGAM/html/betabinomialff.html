<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Beta-binomial Distribution Family Function</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for betabinomialff {VGAM}"><tr><td>betabinomialff {VGAM}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2> Beta-binomial Distribution Family Function </h2>

<h3>Description</h3>

<p>Fits a beta-binomial distribution by maximum likelihood estimation.
The two parameters here are the shape parameters of the underlying
beta distribution.
</p>


<h3>Usage</h3>

<pre>
betabinomialff(lshape1 = "loge", lshape2 = "loge", ishape1 = 1,
               ishape2 = NULL, imethod = 1, ishrinkage = 0.95,
               nsimEIM = NULL, zero = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>lshape1, lshape2</code></td>
<td>
 
<p>Link functions for the two (positive) shape parameters
of the beta distribution.
See <code><a href="Links.html">Links</a></code> for more choices.
</p>
</td></tr>
<tr valign="top"><td><code>ishape1, ishape2</code></td>
<td>
 
<p>Initial value for the shape parameters.
The first must be positive, and is recyled to the necessary length.
The second is optional.
If a failure to converge occurs, try assigning a different value
to <code>ishape1</code> and/or using <code>ishape2</code>.
</p>
</td></tr>
<tr valign="top"><td><code>zero</code></td>
<td>
 
<p>Can be
an integer specifying which linear/additive predictor is to be modelled
as an intercept only. If assigned, the single value should be either
<code>1</code> or <code>2</code>. The default is to model both shape parameters
as functions of the covariates. If a failure to converge occurs,
try <code>zero = 2</code>.
See <code><a href="CommonVGAMffArguments.html">CommonVGAMffArguments</a></code> for more information.
</p>
</td></tr>
<tr valign="top"><td><code>ishrinkage, nsimEIM, imethod</code></td>
<td>

<p>See <code><a href="CommonVGAMffArguments.html">CommonVGAMffArguments</a></code> for more information.
The argument <code>ishrinkage</code> is used only if <code>imethod = 2</code>.
Using the argument <code>nsimEIM</code> may offer large advantages for large
values of <i>N</i> and/or large data sets.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are several parameterizations of the beta-binomial distribution.
This family function directly models the two shape parameters of the
associated beta distribution rather than the probability of
success (however, see <b>Note</b> below). 
The model can be written
<i>T|P=p ~ Binomial(N,p)</i>
where <i>P</i> has a beta distribution with shape parameters
<i>alpha</i> and <i>beta</i>. Here,
<i>N</i> is the number of trials (e.g., litter size),
<i>T=NY</i> is the number of successes, and
<i>p</i> is the probability of a success (e.g., a malformation).
That is, <i>Y</i> is the <em>proportion</em> of successes. Like
<code><a href="binomialff.html">binomialff</a></code>, the fitted values are the
estimated probability
of success (i.e., <i>E[Y]</i> and not <i>E[T]</i>) 
and the prior weights <i>N</i> are attached separately on the
object in a slot.
</p>
<p>The probability function is
</p>
<p style="text-align: center;"><i>
        P(T=t) = choose(N,t) B(alpha+t, beta+N-t) / B(alpha, beta)</i></p>

<p>where <i>t=0,1,&hellip;,N</i>, and <i>B</i> is the beta function
with shape parameters <i>alpha</i> and <i>beta</i>.
Recall <i>Y = T/N</i> is the real response being modelled.
</p>
<p>The default model is <i>eta1 = log(alpha)</i>
and <i>eta2 = log(beta)</i> because both
parameters are positive.
The mean (of <i>Y</i>) is 
<i>p = mu = alpha / (alpha + beta)</i>
and the variance (of <i>Y</i>) is 
<i>mu(1-mu)(1+(N-1)rho)/N</i>.
Here, the correlation <i>rho</i> is given by
<i>1/(1 + alpha + beta)</i>
and is the correlation between the <i>N</i> individuals
within a litter. A <em>litter effect</em> is typically reflected by a
positive value of <i>rho</i>. It is known as the
<em>over-dispersion parameter</em>.
</p>
<p>This family function uses Fisher scoring. The two diagonal
elements of the second-order expected
derivatives with respect to <i>alpha</i> and 
<i>beta</i> are computed numerically, which may 
fail for large <i>alpha</i>, <i>beta</i>, 
<i>N</i> or else take a long time.
</p>


<h3>Value</h3>

<p>An object of class <code>"vglmff"</code> (see <code><a href="vglmff-class.html">vglmff-class</a></code>).
The object is used by modelling functions such as <code><a href="vglm.html">vglm</a></code>.
</p>
<p>Suppose <code>fit</code> is a fitted beta-binomial model. Then
<code>fit@y</code> (better: <code>depvar(fit)</code>) contains the sample
proportions <i>y</i>, <code>fitted(fit)</code> returns estimates of
<i>E(Y)</i>, and <code>weights(fit, type = "prior")</code> returns
the number of trials <i>N</i>.
</p>


<h3>Warning </h3>

<p>This family function is prone to numerical difficulties
due to the expected information matrices not being positive-definite
or ill-conditioned over some regions of the parameter space.
If problems occur try setting <code>ishape1</code> to be some other
positive value, using <code>ishape2</code> and/or setting <code>zero = 2</code>.
</p>
<p>This family function may be renamed in the future.
See the warnings in <code><a href="betabinomial.html">betabinomial</a></code>.
</p>


<h3>Note</h3>

<p>This function processes the input in the same way
as <code><a href="binomialff.html">binomialff</a></code>. But it does not handle 
the case <i>N=1</i> very well because there are two
parameters to estimate, not one, for each row of the input.
Cases where <i>N=1</i> can be omitted via the 
<code>subset</code> argument of <code><a href="vglm.html">vglm</a></code>.
</p>
<p>Although the two linear/additive predictors given
above are in terms of <i>alpha</i> and <i>beta</i>,
basic algebra shows that the default amounts to
fitting a logit link to the probability of success; subtracting
the second linear/additive predictor from the first gives that
logistic regression linear/additive predictor.
That is, <i>logit(p) = eta1 - eta2</i>.
This is illustated in one of the examples below.
</p>
<p>The <em>extended</em> beta-binomial distribution of Prentice (1986)
is currently not implemented in the <span class="pkg">VGAM</span> package as it has
range-restrictions for the correlation parameter that are currently
too difficult to handle in this package.
</p>


<h3>Author(s)</h3>

<p> T. W. Yee </p>


<h3>References</h3>

<p>Moore, D. F. and Tsiatis, A. (1991)
Robust estimation of the variance in moment methods for
extra-binomial and extra-Poisson variation.
<em>Biometrics</em>,
<b>47</b>, 383&ndash;401.
</p>
<p>Prentice, R. L. (1986)
Binary regression using an extended beta-binomial distribution,
with discussion of correlation induced by
covariate measurement errors.
<em>Journal of the American Statistical Association</em>,
<b>81</b>, 321&ndash;327.
</p>


<h3>See Also</h3>

<p><code><a href="betabinomial.html">betabinomial</a></code>,
<code><a href="betabinomUC.html">Betabinom</a></code>,
<code><a href="binomialff.html">binomialff</a></code>,
<code><a href="betaff.html">betaff</a></code>,
<code><a href="dirmultinomial.html">dirmultinomial</a></code>,
<code><a href="lirat.html">lirat</a></code>,
<code><a href="simulate.vlm.html">simulate.vlm</a></code>.
</p>


<h3>Examples</h3>

<pre>
# Example 1
N &lt;- 10; s1 &lt;- exp(1); s2 &lt;- exp(2)
y &lt;- rbetabinom.ab(n = 100, size = N, shape1 = s1, shape2 = s2)
fit &lt;- vglm(cbind(y, N-y) ~ 1, betabinomialff, trace = TRUE)
coef(fit, matrix = TRUE)
Coef(fit)
head(fit@misc$rho)  # The correlation parameter
head(cbind(depvar(fit), weights(fit, type = "prior")))


# Example 2
fit &lt;- vglm(cbind(R, N-R) ~ 1, betabinomialff, data = lirat,
            trace = TRUE, subset = N &gt; 1)
coef(fit, matrix = TRUE)
Coef(fit)
fit@misc$rho  # The correlation parameter
t(fitted(fit))
t(depvar(fit))
t(weights(fit, type = "prior"))
# A "loge" link for the 2 shape parameters is a logistic regression:
all.equal(c(fitted(fit)),
          as.vector(logit(predict(fit)[, 1] -
                          predict(fit)[, 2], inverse = TRUE)))


# Example 3, which is more complicated
lirat &lt;- transform(lirat, fgrp = factor(grp))
summary(lirat)  # Only 5 litters in group 3
fit2 &lt;- vglm(cbind(R, N-R) ~ fgrp + hb, betabinomialff(zero = 2),
           data = lirat, trace = TRUE, subset = N &gt; 1)
coef(fit2, matrix = TRUE)
coef(fit2, matrix = TRUE)[, 1] -
coef(fit2, matrix = TRUE)[, 2]  # logit(p)
## Not run:  with(lirat, plot(hb[N &gt; 1], fit2@misc$rho,
                 xlab = "Hemoglobin", ylab = "Estimated rho",
                 pch = as.character(grp[N &gt; 1]), col = grp[N &gt; 1])) 
## End(Not run)
## Not run:   # cf. Figure 3 of Moore and Tsiatis (1991)
with(lirat, plot(hb, R / N, pch = as.character(grp), col = grp, las = 1,
            xlab = "Hemoglobin level", ylab = "Proportion Dead",
            main = "Fitted values (lines)"))

smalldf &lt;- with(lirat, lirat[N &gt; 1, ])
for (gp in 1:4) {
  xx &lt;- with(smalldf, hb[grp == gp])
  yy &lt;- with(smalldf, fitted(fit2)[grp == gp])
  ooo &lt;- order(xx)
  lines(xx[ooo], yy[ooo], col = gp)
} 
## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>VGAM</em> version 1.0-2 <a href="00Index.html">Index</a>]</div>
</body></html>
