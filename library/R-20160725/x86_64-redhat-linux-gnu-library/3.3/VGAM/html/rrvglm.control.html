<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Control Function for rrvglm()</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for rrvglm.control {VGAM}"><tr><td>rrvglm.control {VGAM}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2> Control Function for rrvglm() </h2>

<h3>Description</h3>

<p>Algorithmic constants and parameters for running <code>rrvglm</code> are set
using this function.
</p>


<h3>Usage</h3>

<pre>
rrvglm.control(Rank = 1, Algorithm = c("alternating", "derivative"),
    Corner = TRUE, Uncorrelated.latvar = FALSE,
    Wmat = NULL, Svd.arg = FALSE,
    Index.corner = if (length(str0)) 
    head((1:1000)[-str0], Rank) else 1:Rank,
    Ainit = NULL, Alpha = 0.5, Bestof = 1, Cinit = NULL,
    Etamat.colmax = 10,
    sd.Ainit = 0.02, sd.Cinit = 0.02, str0 = NULL,
    noRRR = ~1, Norrr = NA,
    noWarning = FALSE,
    trace = FALSE, Use.Init.Poisson.QO = FALSE, 
    checkwz = TRUE, Check.rank = TRUE, Check.cm.rank = TRUE,
    wzepsilon = .Machine$double.eps^0.75, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>Rank</code></td>
<td>

<p>The numerical rank <i>R</i> of the model.
Must be an element from the set {1,2,...,min(<i>M</i>,<em>p2</em>)}. 
Here, the vector of explanatory variables <b>x</b> is partitioned into
(<b>x1</b>,<b>x2</b>), which is of dimension <em>p1</em>+<em>p2</em>.
The variables making up <b>x1</b> are given by the terms in
<code>noRRR</code> argument, and the rest of the terms comprise <b>x2</b>.
</p>
</td></tr>
<tr valign="top"><td><code>Algorithm</code></td>
<td>

<p>Character string indicating what algorithm is
to be used. The default is the first one.
</p>
</td></tr>
<tr valign="top"><td><code>Corner</code></td>
<td>

<p>Logical indicating whether corner constraints are
to be used. This is one method for ensuring a unique solution.
If <code>TRUE</code>, <code>Index.corner</code> specifies the <i>R</i> rows
of the constraint matrices that are use as the corner constraints,
i.e., they hold an order-<i>R</i> identity matrix.
</p>
</td></tr>
<tr valign="top"><td><code>Uncorrelated.latvar</code></td>
<td>

<p>Logical indicating whether uncorrelated latent variables are to be used.
This is normalization forces the variance-covariance
matrix of the latent variables to be <code>diag(Rank)</code>, i.e., unit
variance and uncorrelated. This constraint does not lead to a unique
solution because it can be rotated.
</p>
</td></tr>
<tr valign="top"><td><code>Wmat</code></td>
<td>
<p> Yet to be done. </p>
</td></tr>
<tr valign="top"><td><code>Svd.arg</code></td>
<td>

<p>Logical indicating whether a singular value decomposition
of the outer product is to computed.  This is another normalization
which ensures uniqueness.  See the argument <code>Alpha</code> below.
</p>
</td></tr>
<tr valign="top"><td><code>Index.corner</code></td>
<td>

<p>Specifies the <i>R</i> rows of the constraint matrices that are
used for the corner constraints, i.e., they hold an order-<i>R</i>
identity matrix.
</p>
</td></tr>
<tr valign="top"><td><code>Alpha</code></td>
<td>

<p>The exponent in the singular value decomposition that is used in
the first part: if the SVD is
<i> U %*% D %*% t(V) </i> then the
first and second parts are 
<i> U %*% D^Alpha</i> 
and
<i>D^(1-Alpha) %*% t(V)</i> respectively.
A value of 0.5 is &lsquo;symmetrical&rsquo;. 
This argument is used only when <code>Svd.arg=TRUE</code>.
</p>
</td></tr>
<tr valign="top"><td><code>Bestof</code></td>
<td>

<p>Integer. The best of <code>Bestof</code> models fitted is
returned. This argument helps guard against local solutions by
(hopefully) finding the global solution from many fits. The
argument works only when the function generates its own initial value
for <b>C</b>,
i.e., when <b>C</b> is <em>not</em> passed in as initial values.
</p>
</td></tr>
<tr valign="top"><td><code>Ainit, Cinit</code></td>
<td>

<p>Initial <b>A</b> and <b>C</b> matrices which may speed up convergence.
They must be of the correct dimension.
</p>
</td></tr>
<tr valign="top"><td><code>Etamat.colmax</code></td>
<td>

<p>Positive integer, no smaller than <code>Rank</code>.  Controls the amount
of memory used by <code>.Init.Poisson.QO()</code>.  It is the maximum
number of columns allowed for the pseudo-response and its weights.
In general, the larger the value, the better the initial value.
Used only if <code>Use.Init.Poisson.QO=TRUE</code>.
</p>
</td></tr>
</table>





<table summary="R argblock">
<tr valign="top"><td><code>str0</code></td>
<td>

<p>Integer vector specifying which rows
of the estimated constraint matrices (<b>A</b>) are
to be all zeros.
These are called <em>structural zeros</em>.
Must not have any common value with <code>Index.corner</code>,
and be a subset of the vector <code>1:M</code>.
The default, <code>str0 = NULL</code>, means no structural zero rows at all.
</p>
</td></tr>
<tr valign="top"><td><code>sd.Ainit, sd.Cinit</code></td>
<td>

<p>Standard deviation of the initial values for the elements
of <b>A</b> and <b>C</b>.
These are normally distributed with mean zero.  
This argument is used only if <code>Use.Init.Poisson.QO = FALSE</code>.
</p>
</td></tr>
</table>

<table summary="R argblock">
<tr valign="top"><td><code>noRRR</code></td>
<td>

<p>Formula giving terms that are <em>not</em> to be included
in the reduced-rank regression.
That is, <code>noRRR</code> specifes which explanatory variables
are in the <i>x1</i> vector of <code><a href="rrvglm.html">rrvglm</a></code>,
and the rest go into <i>x2</i>.
The <i>x1</i> variables constitute
the <i>\bold{B}1</i> matrix in Yee and Hastie (2003).
Those <i>x2</i> variables which are subject to the reduced-rank
regression correspond to the <i>\bold{B}2</i>
matrix.
Set <code>noRRR = NULL</code> for the reduced-rank regression to
be applied to every explanatory variable including the intercept.
</p>
</td></tr>
<tr valign="top"><td><code>Norrr</code></td>
<td>

<p>Defunct. Please use <code>noRRR</code>.
Use of <code>Norrr</code> will become an error soon.
</p>
</td></tr>
<tr valign="top"><td><code>trace</code></td>
<td>

<p>Logical indicating if output should be produced for
each iteration.
</p>



</td></tr>
<tr valign="top"><td><code>Use.Init.Poisson.QO</code></td>
<td>

<p>Logical indicating whether the <code>.Init.Poisson.QO()</code> should
be used to obtain initial values for the <b>C</b>.  The function
uses a new method that can work well if the data are Poisson counts
coming from an equal-tolerances QRR-VGLM (CQO).  This option is less
realistic for RR-VGLMs compared to QRR-VGLMs.
</p>
</td></tr>
<tr valign="top"><td><code>checkwz</code></td>
<td>

<p>logical indicating whether the diagonal elements of
the working weight matrices should be checked whether they are
sufficiently positive, i.e., greater than <code>wzepsilon</code>. If not,
any values less than <code>wzepsilon</code> are replaced with this value.
</p>
</td></tr>
<tr valign="top"><td><code>noWarning, Check.rank, Check.cm.rank</code></td>
<td>

<p>Same as <code><a href="vglm.control.html">vglm.control</a></code>.
Ignored for <span class="pkg">VGAM</span> 0.9-7 and higher.
</p>
</td></tr>
<tr valign="top"><td><code>wzepsilon</code></td>
<td>

<p>Small positive number used to test whether the diagonals of the working
weight matrices are sufficiently positive.
</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>

<p>Variables in ... are passed into
<code><a href="vglm.control.html">vglm.control</a></code>.
If the derivative algorithm is used then ... are also passed
into <code><a href="rrvglm.optim.control.html">rrvglm.optim.control</a></code>;
and
if the alternating algorithm is used then ... are also passed
into <code><a href="notdocumentedyet.html">valt.control</a></code>.
</p>
</td></tr>
</table>
<p>In the above, <i>R</i> is the <code>Rank</code> and 
<i>M</i> is the number of linear predictors.
</p>


<h3>Details</h3>










<p><span class="pkg">VGAM</span> supports three normalizations to ensure a unique
solution. Of these, only corner constraints will work with
<code>summary</code> of RR-VGLM objects.
</p>


<h3>Value</h3>

<p>A list with components matching the input names.
Some error checking is done, but not much.
</p>


<h3>Note</h3>




<p>The arguments in this function begin with an upper case letter to help
avoid interference with those of <code><a href="vglm.control.html">vglm.control</a></code>.
</p>
<p>In the example below a rank-1 <em>stereotype</em> model (Anderson, 1984)
is fitted.
</p>


<h3>Author(s)</h3>

<p> Thomas W. Yee </p>


<h3>References</h3>

<p>Yee, T. W. and Hastie, T. J. (2003)
Reduced-rank vector generalized linear models.
<em>Statistical Modelling</em>,
<b>3</b>, 15&ndash;41.
</p>


<h3>See Also</h3>

<p><code><a href="rrvglm.html">rrvglm</a></code>,
<code><a href="rrvglm.optim.control.html">rrvglm.optim.control</a></code>,
<code><a href="rrvglm-class.html">rrvglm-class</a></code>,
<code><a href="vglm.html">vglm</a></code>,
<code><a href="vglm.control.html">vglm.control</a></code>,
<code><a href="cqo.html">cqo</a></code>.
</p>


<h3>Examples</h3>

<pre>
## Not run: 
set.seed(111)
pneumo &lt;- transform(pneumo, let = log(exposure.time),
                            x3 = runif(nrow(pneumo)))  # x3 is random noise
fit &lt;- rrvglm(cbind(normal, mild, severe) ~ let + x3,
              multinomial, data = pneumo, Rank = 1, Index.corner = 2)
constraints(fit)
vcov(fit)
summary(fit)

## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>VGAM</em> version 1.0-2 <a href="00Index.html">Index</a>]</div>
</body></html>
