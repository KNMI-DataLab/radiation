<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Fit an Additive Spline Model by Adaptive Backfitting</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for bruto {mda}"><tr><td>bruto {mda}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>
Fit an Additive Spline Model by Adaptive Backfitting
</h2>

<h3>Description</h3>

<p>Fit an additive spline model by adaptive backfitting.
</p>


<h3>Usage</h3>

<pre>
bruto(x, y, w, wp, dfmax, cost, maxit.select, maxit.backfit, 
      thresh = 0.0001, trace.bruto = FALSE, start.linear = TRUE,
      fit.object, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>a matrix of numeric predictors (does not include the column
of 1s).</p>
</td></tr>
<tr valign="top"><td><code>y</code></td>
<td>
<p>a vector or matrix of responses.</p>
</td></tr>
<tr valign="top"><td><code>w</code></td>
<td>
<p>optional observation weight vector.</p>
</td></tr>
<tr valign="top"><td><code>wp</code></td>
<td>
<p>optional weight vector for each column of <code>y</code>; the RSS
and GCV criteria use a weighted sum of squared residuals.</p>
</td></tr>
<tr valign="top"><td><code>dfmax</code></td>
<td>
<p>a vector of maximum df (degrees of freedom) for each
term.</p>
</td></tr>
<tr valign="top"><td><code>cost</code></td>
<td>
<p>cost per degree of freedom; default is 2.</p>
</td></tr>
<tr valign="top"><td><code>maxit.select</code></td>
<td>
<p>maximum number of iterations during the selection
stage.</p>
</td></tr>
<tr valign="top"><td><code>maxit.backfit</code></td>
<td>
<p>maximum number of iterations for the final
backfit stage (with fixed lambda).</p>
</td></tr> 
<tr valign="top"><td><code>thresh</code></td>
<td>
<p>convergence threshold (default is 0.0001); iterations
cease when the relative change in GCV is below this threshold.</p>
</td></tr> 
<tr valign="top"><td><code>trace.bruto</code></td>
<td>
<p>logical flag.  If <code>TRUE</code> (default) a progress
report is printed during the fitting.</p>
</td></tr>
<tr valign="top"><td><code>start.linear</code></td>
<td>
<p>logical flag.  If <code>TRUE</code> (default), the model
starts with the linear fit.</p>
</td></tr>
<tr valign="top"><td><code>fit.object</code></td>
<td>
<p>This the object returned by <code>bruto()</code>; if
supplied, the same model is fit to the presumably new <code>y</code>.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A multiresponse additive model fit object of class <code>"bruto"</code> is
returned.  The model is fit by adaptive backfitting using smoothing
splines.  If there are <code>np</code> columns in <code>y</code>, then <code>np</code>
additive models are fit, but the same amount of smoothing (df) is 
used for  each term.  The procedure chooses between <code>df = 0</code>
(term omitted), <code>df = 1</code> (term linear) or <code>df &gt; 0</code> (term
fitted by smoothing spline).  The model selection is based on an
approximation to the  GCV criterion, which is used at each step of the
backfitting procedure.  Once the selection process stops, the model is
backfit using the chosen amount of smoothing.
</p>
<p>A bruto object has the following components of interest:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>lambda</code></td>
<td>
<p>a vector of chosen smoothing parameters, one for each
column of <code>x</code>.</p>
</td></tr>
<tr valign="top"><td><code>df</code></td>
<td>
<p>the df chosen for each column of <code>x</code>.</p>
</td></tr>
<tr valign="top"><td><code>type</code></td>
<td>
<p>a factor with levels <code>"excluded"</code>, <code>"linear"</code> or
<code>"smooth"</code>, indicating the status of each column of <code>x</code>.</p>
</td></tr>
<tr valign="top"><td><code>gcv.select gcv.backfit df.select</code></td>
<td>
<p>The sequence of gcv values and
df selected during the execution of the function.</p>
</td></tr>
<tr valign="top"><td><code>nit</code></td>
<td>
<p>the number of iterations used.</p>
</td></tr>
<tr valign="top"><td><code>fitted.values</code></td>
<td>
<p>a matrix of fitted values.</p>
</td></tr>
<tr valign="top"><td><code>residuals</code></td>
<td>
<p>a matrix of residuals.</p>
</td></tr>
<tr valign="top"><td><code>call</code></td>
<td>
<p>the call that produced this object.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Trevor Hastie and Rob Tibshirani,
<em>Generalized Additive Models</em>,
Chapman and Hall, 1990 (page 262).
</p>
<p>Trevor Hastie, Rob Tibshirani and Andreas Buja
&ldquo;Flexible Discriminant Analysis by Optimal Scoring&rdquo;
JASA 1994, 89, 1255-1270.
</p>


<h3>See Also</h3>

<p><code><a href="predict.bruto.html">predict.bruto</a></code>
</p>


<h3>Examples</h3>

<pre>
data(trees)
fit1 &lt;- bruto(trees[,-3], trees[3])
fit1$type
fit1$df
## examine the fitted functions
par(mfrow=c(1,2), pty="s")
Xp &lt;- matrix(sapply(trees[1:2], mean), nrow(trees), 2, byrow=TRUE)
for(i in 1:2) {
  xr &lt;- sapply(trees, range)
  Xp1 &lt;- Xp; Xp1[,i] &lt;- seq(xr[1,i], xr[2,i], len=nrow(trees))
  Xf &lt;- predict(fit1, Xp1)
  plot(Xp1[ ,i], Xf, xlab=names(trees)[i], ylab="", type="l")
}
</pre>

<hr /><div style="text-align: center;">[Package <em>mda</em> version 0.4-9 <a href="00Index.html">Index</a>]</div>
</body></html>
