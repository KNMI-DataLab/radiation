<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Helper function for applying predict methods to stacks of...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for grid.predict {RSAGA}"><tr><td>grid.predict {RSAGA}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Helper function for applying predict methods to stacks of grids.</h2>

<h3>Description</h3>

<p>This function can be used to apply the predict method of hopefully any fitted predictive model pixel by pixel to a stack of grids representing the explanatory variables. It is intended to be called primarily by <code><a href="multi.focal.function.html">multi.local.function</a></code> or <code><a href="multi.focal.function.html">multi.focal.function</a></code>.
</p>


<h3>Usage</h3>

<pre>
grid.predict(fit, predfun, trafo, control.predict, predict.column, trace = 0,
  location, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>fit</code></td>
<td>
<p>a model object for which prediction is desired</p>
</td></tr>
<tr valign="top"><td><code>predfun</code></td>
<td>
<p>optional prediction function; if missing, the <code>fit</code>'s <code><a href="../../stats/html/predict.html">predict</a></code> method is called. In some cases it may be convenient to define a wrapper function for the predict method that may be passed as <code>predfun</code> argument.</p>
</td></tr>
<tr valign="top"><td><code>trafo</code></td>
<td>
<p>an optional <code>function(x)</code> that takes a <code>data.frame</code> <code>x</code> and returns a <code>data.frame</code> with the same number of rows; this is intended to perform transformations on the input variables, e.g. derive a log-transformed variable from the raw input read from the grids, or more complex variables such as the NDVI etc.; the <code>data.frame</code> resulting from a call to <code>trafo</code> (if provided) is passed to <code>predfun</code></p>
</td></tr>
<tr valign="top"><td><code>control.predict</code></td>
<td>
<p>an optional list of arguments to be passed on to <code>predfun</code>; this may be e.g. <code>type="response"</code> to obtain probability prediction maps from a logistic regression model</p>
</td></tr>
<tr valign="top"><td><code>predict.column</code></td>
<td>
<p>optional character string: Some predict methods (e.g. <code>predict.lda</code>) return a data.frame with several columns, e.g. one column per class in a classification problem. <code>predict.column</code> is used to pick the one that is of interest</p>
</td></tr>
<tr valign="top"><td><code>trace</code></td>
<td>
<p>integer &gt;=0: positive values give more (=2) or less (=1) information on predictor variables and predictions</p>
</td></tr>
<tr valign="top"><td><code>location</code></td>
<td>
<p>optional location data received from <code>multi.focal.function</code>; is added to the <code>newdata</code> object that is passed on to <code>predfun</code>.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>these arguments are provided by the calling function, usually <code><a href="multi.focal.function.html">multi.local.function</a></code> or <code><a href="multi.focal.function.html">multi.focal.function</a></code>.  They contain the explanatory (predictor) variables required by the <code>fit</code> model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>grid.predict</code> is a simple wrapper function. First it binds the arguments in <code>...</code> together in a <code>data.frame</code> with the raw predictor variables that have been read from their grids by the caller, <code><a href="multi.focal.function.html">multi.local.function</a></code> (or <code><a href="multi.focal.function.html">multi.focal.function</a></code>). Then it calls the optional <code>trafo</code> function to transform or combine predictor variables (e.g. perform log transformations, ratioing, arithmetic operations such as calculating the NDVI). Finally the <code>predfun</code> (or, typically, the default <code><a href="../../stats/html/predict.html">predict</a></code> method of <code>fit</code>) is called, handing over the <code>fit</code>, the predictor <code>data.frame</code>, and the optional <code>control.predict</code> arguments.
</p>


<h3>Value</h3>

<p><code>grid.predict</code> returns the result of the call to <code>predfun</code> or the default <code><a href="../../stats/html/predict.html">predict</a></code> method.
</p>


<h3>Note</h3>

<p>Though <code>grid.predict</code> can in principle deal with <code>predict</code> methods returning factor variables, its usual caller <code><a href="multi.focal.function.html">multi.local.function</a></code> / <code><a href="multi.focal.function.html">multi.focal.function</a></code> cannot; classification models should be dealt with by setting a <code>type="prob"</code> (for <code>rpart</code>) or <code>type="response"</code> (for logistic regression and logistic additive model) argument, for example (see second Example below).
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning
</p>


<h3>References</h3>

<p>Brenning, A. (2008): Statistical geocomputing combining R and SAGA: The example of landslide susceptibility analysis with generalized additive models. In: J. Boehner, T. Blaschke, L. Montanarella (eds.), SAGA - Seconds Out (= Hamburger Beitraege zur Physischen Geographie und Landschaftsoekologie, 19), 23-32.
</p>


<h3>See Also</h3>

<p><code><a href="focal.function.html">focal.function</a></code>, <code><a href="multi.focal.function.html">multi.local.function</a></code>, <code><a href="multi.focal.function.html">multi.focal.function</a></code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
# Assume that d is a data.frame with point observations
# of a numerical response variable y and predictor variables
# a, b, and c.
# Fit a generalized additive model to y,a,b,c.
# We want to model b and c as nonlinear terms:
require(gam)
fit &lt;- gam(y ~ a + s(b) + s(c), data = d)
multi.local.function(in.grids = c("a", "b", "c"),
    out.varnames = "pred",
    fun = grid.predict, fit = fit )
    # Note that the 'grid.predict' uses by default the
    # predict method of 'fit'.
# Model predictions are written to a file named pred.asc

## End(Not run)

## Not run: 
# A fake example of a logistic additive model:
require(gam)
fit &lt;- gam(cl ~ a + s(b) + s(c), data = d, family = binomial)
multi.local.function(in.grids = c("a", "b", "c"),
    out.varnames = "pred",
    fun = grid.predict, fit = fit,
    control.predict = list(type = "response") )
    # 'control.predict' is passed on to 'grid.predict', which
    # dumps its contents into the arguments for 'fit''s
    # 'predict' method.
# Model predictions are written to a file named pred.asc

## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>RSAGA</em> version 0.94-5 <a href="00Index.html">Index</a>]</div>
</body></html>
