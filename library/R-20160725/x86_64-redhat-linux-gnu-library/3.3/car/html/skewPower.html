<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Skew Power Transformations</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for skewPower {car}"><tr><td>skewPower {car}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Skew Power Transformations</h2>

<h3>Description</h3>

<p>Transform the elements of a vector using, the skew power transformations.
</p>


<h3>Usage</h3>

<pre>
skewPower(U, lambda, jacobian.adjusted=FALSE, gamma)

## S3 method for class 'skewpowerTransform'
contour(x, ksds = 4, levels = c(0.5, 0.95, 0.99, 0.999), 
                 main = "Skew Power Log-likelihood", ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>U</code></td>
<td>
<p>A vector, matrix or data.frame of values to be transformed</p>
</td></tr>
<tr valign="top"><td><code>lambda</code></td>
<td>
<p>The one-dimensional transformation parameter, usually in 
the range from <i>-2</i> to <i>2</i>, or if <code>U</code> is a matrix or data frame, a vector of length
<code>ncol(U)</code> of transformation parameters</p>
</td></tr>
<tr valign="top"><td><code>jacobian.adjusted</code></td>
<td>
<p>If <code>TRUE</code>, the transformation is normalized to have
Jacobian equal to one.  The default is <code>FALSE</code>.</p>
</td></tr>
<tr valign="top"><td><code>gamma</code></td>
<td>
<p>The skew power family has two parameters, the power lambda, and the start gamma, which can be any positive value.</p>
</td></tr>
<tr valign="top"><td><code>x</code></td>
<td>

<p>An object created by a call to <code><a href="powerTransform.html">powerTransform</a></code> using the <code>family="skewPower"</code> option.
</p>
</td></tr>
<tr valign="top"><td><code>ksds</code></td>
<td>

<p>Contour plotting of the log-likelihood surface will cover plus of minus <code>ksds</code> standard deviations on each axis.
</p>
</td></tr>
<tr valign="top"><td><code>levels</code></td>
<td>

<p>Contours will be drawn at the values of levels.  For example, <code>levels=c(.5, .99)</code> would display two contours, at the 50% level and at the 99% level.
</p>
</td></tr>
<tr valign="top"><td><code>main</code></td>
<td>

<p>Title for the contour plot
</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>

<p>Additional arguments passed to the generic contour function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>skewPower</code> family is a modification of the Box-Cox power family, see <code><a href="bcPower.html">bcPower</a></code> that allows the untransformed response to include negative values.  Ignoring the Jacobian, correction, the Box-Cox family is defined to be <i>(U^(lambda)-1)/lambda</i> 
for <i>lambda not equal to zero</i>, and 
<i>log(U)</i> if <i>lambda = 0</i>.  The <code>skewPower family</code> is the Box-Cox transformation of <i>z = .5 * (U + (U^2 + &gamma;^2)^{1/2})</i>. Zero or negative values for <i>\code{U}</i> are permitted if <i>gamma</i> is positive. 
</p>
<p>If <code>jacobian.adjusted</code> is <code>TRUE</code>, then the transformed values are scaled to have Jacobian equal to 1, as suggested by Box and Cox (1964).  This simplifies computing the maximum likelihood-like estimates of the transformation parameters.  
</p>
<p>Missing values are permitted, and return <code>NA</code> where ever <code>U</code> is equal to <code>NA</code>.
</p>
<p>The contour method allows drawing a contour plot for the two-dimensional log-likelihood for the skew power parameters with a univariate response.
</p>


<h3>Value</h3>

<p>Returns a vector or matrix of transformed values.  The contour method is used for the side-effect of drawing a contour plot.
</p>


<h3>Author(s)</h3>

<p> Sanford Weisberg, &lt;sandy@umn.edu&gt; </p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2011) 
<em>An R Companion to Applied Regression</em>, Second Edition, Sage.
</p>
<p>Hawkins, D. and Weisberg, S. (2015)
Combining the Box-Cox Power and Genralized Log Transformations to Accomodate Negative Responses,
submitted for publication.
</p>
<p>Weisberg, S. (2014)  <em>Applied Linear Regression</em>, Fourth Edition, Wiley
Wiley, Chapter 7.
</p>


<h3>See Also</h3>

<p><code><a href="powerTransform.html">powerTransform</a></code>, <code><a href="bcPower.html">bcPower</a></code>, <code><a href="boxCox.html">boxCox</a></code></p>


<h3>Examples</h3>

<pre>
# Univariate Example from Hawkins and Weisberg (2015)
m1 &lt;- lm(I1L1 ~ pool, LoBD)
p1 &lt;- powerTransform(m1, family="skewPower")
summary(p1)
# summary prints estimate, se and conf.ints for both parameters
# helper functions
coef(p1)
vcov(p1)
p1$value # maximum value of log-likelihood surface

# tests are for lambda, maximizing over gamma (profile log-likelihoods)
testTransform(p1, lambda=0.5)

# Contour plot of the log-likelihood
contour(p1, main="", levels=c(.5, .95, .99))

# the boxCox function can provide profile log-likelihoods for each of the two parameters:
boxCox(m1, family="skewPower", param="lambda", lambda=seq(0.25, 1.1, length=100))
boxCox(m1, family="skewPower", param="gamma", gamma=seq(3, 80, length=100))

#  Create new variate corresponding to the transformation, then update the regression
LoBD$z &lt;- skewPower(LoBD$I1L1, lambda=p1$lambda, gamma=p1$gamma, jacobian.adjusted=FALSE)
m1.t &lt;- update(m1, z ~ . -1)
#  The example in Hawkins and Weisberg(2015) requires computing the inverse of the skew power
# transformation and certain summaries of the updated regression
mu0 &lt;- mean(coef(m1.t)[1:4])
sd &lt;- sigmaHat(m1.t)
LoB &lt;- mu0 + 1.645*sd
LoD &lt;- LoB + 1.645*sd
skewPowerInverse &lt;- function(z, lambda, gamma){
  q &lt;- if(abs(lambda) &lt;= 1.e-9) {2 * log(z)} else {2*(z*lambda + 1) ^(1/lambda)}
  (q^2 - gamma^2)/(2 * q)
}
y.untransformed &lt;- round(skewPowerInverse(c(LoB, LoD), p1$lambda, p1$gamma), 2)

# Multivariate Response
p3 &lt;- powerTransform(update(m1, as.matrix(cbind(LoBD$I1L2, LoBD$I1L1)) ~ .), family="skewPower")
summary(p3)
# Construct test for the same transformations for each response.  Get new data file by stacking
d2 &lt;- data.frame(assay = c(LoBD$I1L2, LoBD$I1L1), pool=factor(c(LoBD$pool, LoBD$pool)),
                 set=factor(rep(c("A", "B"), c(84, 84))))
# the following allows for different within set means, but common transformation parameters
p5 &lt;- powerTransform(lm(assay ~ pool*set, d2), family="skewPower") # allow grps to differ by set.
c(df=(df &lt;- length(coef(p3)) - length(coef(p5))),
  test = (test &lt;- -.5 * (p5$value - p3$value)),
  pvalue = 1 - pchisq(test, df))

</pre>

<hr /><div style="text-align: center;">[Package <em>car</em> version 2.1-3 <a href="00Index.html">Index</a>]</div>
</body></html>
