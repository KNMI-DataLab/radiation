<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Gradient Descent Algorithm for the 2D case</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for grad.desc {animation}"><tr><td>grad.desc {animation}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Gradient Descent Algorithm for the 2D case</h2>

<h3>Description</h3>

<p>This function provids a visual illustration for the process of minimizing a
real-valued function through Gradient Descent Algorithm.
</p>


<h3>Usage</h3>

<pre>
grad.desc(FUN = function(x, y) x^2 + 2 * y^2, rg = c(-3, -3, 3, 3), init = c(-3, 
    3), gamma = 0.05, tol = 0.001, gr = NULL, len = 50, interact = FALSE, 
    col.contour = "red", col.arrow = "blue", main)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>FUN</code></td>
<td>
<p>a bivariate objective function to be minimized (variable names do
not have to be <code>x</code> and <code>y</code>); if the gradient argument <code>gr</code>
is <code>NULL</code>, <code><a href="../../stats/html/deriv.html">deriv</a></code> will be used to calculate the gradient,
in which case we should not put braces around the function body of
<code>FUN</code> (e.g. the default function is <code>function(x, y) x^2 + 2 *
y^2</code>)</p>
</td></tr>
<tr valign="top"><td><code>rg</code></td>
<td>
<p>ranges for independent variables to plot contours; in a <code>c(x0,
y0, x1, y1)</code> form</p>
</td></tr>
<tr valign="top"><td><code>init</code></td>
<td>
<p>starting values</p>
</td></tr>
<tr valign="top"><td><code>gamma</code></td>
<td>
<p>size of a step</p>
</td></tr>
<tr valign="top"><td><code>tol</code></td>
<td>
<p>tolerance to stop the iterations, i.e. the minimum difference
between <i>F(x[i])</i> and <i>F(x[i+1])</i></p>
</td></tr>
<tr valign="top"><td><code>gr</code></td>
<td>
<p>the gradient of <code>FUN</code>; it should be a bivariate function to
calculate the gradient (not the negative gradient!) of <code>FUN</code> at a
point <i>(x,y)</i>, e.g. <code>function(x, y) 2 * x + 4 * y</code>. If it is
<code>NULL</code>, R will use <code><a href="../../stats/html/deriv.html">deriv</a></code> to calculate the gradient</p>
</td></tr>
<tr valign="top"><td><code>len</code></td>
<td>
<p>desired length of the independent sequences (to compute z values
for contours)</p>
</td></tr>
<tr valign="top"><td><code>interact</code></td>
<td>
<p>logical; whether choose the starting values by clicking on the
contour plot directly?</p>
</td></tr>
<tr valign="top"><td><code>col.contour, col.arrow</code></td>
<td>
<p>colors for the contour lines and arrows
respectively (default to be red and blue)</p>
</td></tr>
<tr valign="top"><td><code>main</code></td>
<td>
<p>the title of the plot; if missing, it will be derived from
<code>FUN</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gradient descent is an optimization algorithm. To find a local minimum of a
function using gradient descent, one takes steps proportional to the negative
of the gradient (or the approximate gradient) of the function at the current
point. If instead one takes steps proportional to the gradient, one
approaches a local maximum of that function; the procedure is then known as
gradient ascent.
</p>
<p>The arrows are indicating the result of iterations and the process of
minimization; they will go to a local minimum in the end if the maximum
number of iterations <code>ani.options('nmax')</code> has not been reached.
</p>


<h3>Value</h3>

<p>A list containing </p>
<table summary="R valueblock">
<tr valign="top"><td><code>par </code></td>
<td>
<p>the solution for the local minimum</p>
</td></tr>
<tr valign="top"><td><code>value </code></td>
<td>
<p>the value of the objective function corresponding to
<code>par</code></p>
</td></tr> <tr valign="top"><td><code>iter</code></td>
<td>
<p>the number of iterations; if it is equal to
<code>ani.options('nmax')</code>, it's quite likely that the solution is not
reliable because the maximum number of iterations has been reached</p>
</td></tr>
<tr valign="top"><td><code>gradient</code></td>
<td>
<p>the gradient function of the objective function</p>
</td></tr>
<tr valign="top"><td><code>persp</code></td>
<td>
<p>a function to make the perspective plot of the objective
function; can accept further arguments from <code><a href="../../graphics/html/persp.html">persp</a></code> (see the
examples below)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Please make sure the function <code>FUN</code> provided is differentiable at
<code>init</code>, what's more, it should also be 'differentiable' using
<code><a href="../../stats/html/deriv.html">deriv</a></code> if you do not provide the gradient function <code>gr</code>.
</p>
<p>If the arrows cannot reach the local minimum, the maximum number of
iterations <code>nmax</code> in <code><a href="ani.options.html">ani.options</a></code> may need to be
increased.
</p>


<h3>Author(s)</h3>

<p>Yihui Xie
</p>


<h3>References</h3>

<p><a href="http://vis.supstat.com/2013/03/gradient-descent-algorithm-with-r/">http://vis.supstat.com/2013/03/gradient-descent-algorithm-with-r/</a>
</p>


<h3>See Also</h3>

<p><code><a href="../../stats/html/deriv.html">deriv</a></code>, <code><a href="../../graphics/html/persp.html">persp</a></code>, <code><a href="../../graphics/html/contour.html">contour</a></code>,
<code><a href="../../stats/html/optim.html">optim</a></code>
</p>


<h3>Examples</h3>

<pre>
## default example
oopt = ani.options(interval = 0.3, nmax = ifelse(interactive(), 50, 2))
xx = grad.desc()
xx$par  # solution
xx$persp(col = "lightblue", phi = 30)  # perspective plot

## define more complex functions; a little time-consuming
f1 = function(x, y) x^2 + 3 * sin(y)
xx = grad.desc(f1, pi * c(-2, -2, 2, 2), c(-2 * pi, 2))
xx$persp(col = "lightblue", theta = 30, phi = 30)

## need to provide the gradient when deriv() cannot handle the function
grad.desc(FUN = function(x1, x2) {
    x0 = cos(x2)
    x1^2 + x0
}, gr = function(x1, x2) {
    c(2 * x1, -sin(x2))
}, rg = c(-3, -1, 3, 5), init = c(-3, 0.5), main = expression(x[1]^2 + cos(x[2])))

## or a even more complicated function
ani.options(interval = 0, nmax = ifelse(interactive(), 200, 2))
f2 = function(x, y) sin(1/2 * x^2 - 1/4 * y^2 + 3) * cos(2 * x + 1 - exp(y))
xx = grad.desc(f2, c(-2, -2, 2, 2), c(-1, 0.5), gamma = 0.1, tol = 1e-04)

## click your mouse to select a start point
if (interactive()) {
    xx = grad.desc(f2, c(-2, -2, 2, 2), interact = TRUE, tol = 1e-04)
    xx$persp(col = "lightblue", theta = 30, phi = 30)
}

## HTML animation pages
saveHTML({
    ani.options(interval = 0.3)
    grad.desc()
}, img.name = "grad.desc", htmlfile = "grad.desc.html", ani.height = 500, 
    ani.width = 500, title = "Demonstration of the Gradient Descent Algorithm", 
    description = "The arrows will take you to the optimum step by step.")

ani.options(oopt)
</pre>

<hr /><div style="text-align: center;">[Package <em>animation</em> version 2.4 <a href="00Index.html">Index</a>]</div>
</body></html>
