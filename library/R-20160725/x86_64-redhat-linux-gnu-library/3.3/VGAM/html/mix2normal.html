<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Mixture of Two Univariate Normal Distributions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for mix2normal {VGAM}"><tr><td>mix2normal {VGAM}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2> Mixture of Two Univariate Normal Distributions </h2>

<h3>Description</h3>

<p>Estimates the five parameters of a mixture of two univariate 
normal distributions by maximum likelihood estimation.
</p>


<h3>Usage</h3>

<pre>
mix2normal(lphi = "logit", lmu = "identitylink", lsd = "loge",
           iphi = 0.5, imu1 = NULL, imu2 = NULL, isd1 = NULL, isd2 = NULL,
           qmu = c(0.2, 0.8), eq.sd = TRUE, nsimEIM = 100, zero = "phi")
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>lphi,lmu,lsd</code></td>
<td>

<p>Link functions for the parameters <i>phi</i>,
<i>mu</i>, and
<i>sd</i>.
See <code><a href="Links.html">Links</a></code> for more choices.
</p>
</td></tr>
</table>





<table summary="R argblock">
<tr valign="top"><td><code>iphi</code></td>
<td>

<p>Initial value for <i>phi</i>, whose value must lie
between 0 and 1.
</p>
</td></tr>
<tr valign="top"><td><code>imu1, imu2</code></td>
<td>

<p>Optional initial value for <i>mu1</i> and <i>mu2</i>.
The default is to compute initial values internally using
the argument <code>qmu</code>.
</p>
</td></tr>
<tr valign="top"><td><code>isd1, isd2</code></td>
<td>

<p>Optional initial value for <i>sd1</i> and <i>sd2</i>.
The default is to compute initial values internally based on
the argument <code>qmu</code>.
Currently these are not great, therefore using these arguments 
where practical is a good idea.
</p>
</td></tr>
<tr valign="top"><td><code>qmu</code></td>
<td>

<p>Vector with two values giving the probabilities relating to the sample
quantiles for obtaining initial values for <i>mu1</i>
and <i>mu2</i>.
The two values are fed in as the <code>probs</code> argument into
<code><a href="../../stats/html/quantile.html">quantile</a></code>.
</p>
</td></tr>
<tr valign="top"><td><code>eq.sd</code></td>
<td>

<p>Logical indicating whether the two standard deviations should be 
constrained to be equal. If <code>TRUE</code> then the appropriate
constraint matrices will be used.
</p>
</td></tr>
<tr valign="top"><td><code>nsimEIM</code></td>
<td>

<p>See <code><a href="CommonVGAMffArguments.html">CommonVGAMffArguments</a></code>.
</p>
</td></tr>
<tr valign="top"><td><code>zero</code></td>
<td>

<p>May be an integer vector
specifying which linear/additive predictors are modelled as
intercept-only.  If given, the value or values can be from the
set <i>1,2,...,5</i>. 
The default is the first one only, meaning <i>phi</i>
is a single parameter even when there are explanatory variables.
Set <code>zero = NULL</code> to model all linear/additive predictors as
functions of the explanatory variables.
See <code><a href="CommonVGAMffArguments.html">CommonVGAMffArguments</a></code> for more information.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The probability density function can be loosely written as 
</p>
<p style="text-align: center;"><i>
        f(y) = phi * N(mu1, sd1) + (1-phi) * N(mu2, sd2)</i></p>

<p>where <i>phi</i> is the probability an observation belongs
to the first group.
The parameters <i>mu1</i> and <i>mu2</i> are the means, and 
<i>sd1</i> and <i>sd2</i> are the standard deviations.
The parameter <i>phi</i> satisfies <i>0 &lt; phi &lt; 1</i>.
The mean of <i>Y</i> is
<i>phi*mu1 + (1-phi)*mu2</i>
and this is returned as the fitted values.
By default, the five linear/additive predictors are
<i>
       (logit(phi),   mu1,   log(sd1), mu2, log(sd2))^T</i>.
If <code>eq.sd = TRUE</code> then <i>sd1=sd2</i>
is enforced.
</p>


<h3>Value</h3>

<p>An object of class <code>"vglmff"</code> (see <code><a href="vglmff-class.html">vglmff-class</a></code>).
The object is used by modelling functions such as <code><a href="vglm.html">vglm</a></code>,
and <code><a href="vgam.html">vgam</a></code>.
</p>


<h3>Warning </h3>

<p>Numerical problems can occur and
half-stepping is not uncommon.
If failure to converge occurs, try inputting better initial values,
e.g., by using <code>iphi</code>,
<code>qmu</code>,
<code>imu1</code>,
<code>imu2</code>,
<code>isd1</code>,
<code>isd2</code>,
etc.
</p>






<p>This <span class="pkg">VGAM</span> family function is experimental and
should be used with care.
</p>


<h3>Note</h3>

<p>Fitting this model successfully to data can be difficult due to
numerical problems and ill-conditioned data.  It pays to fit the
model several times with different initial values and check that
the best fit looks reasonable. Plotting the results is recommended.
This function works better as <i>mu1</i> and <i>mu2</i>
become more different.
</p>
<p>Convergence can be slow, especially when the two component
distributions are not well separated.
The default control argument <code>trace = TRUE</code> is to encourage
monitoring convergence.
Having <code>eq.sd = TRUE</code> often makes the overall optimization problem
easier.
</p>


<h3>Author(s)</h3>

<p> T. W. Yee </p>


<h3>References</h3>

<p>McLachlan, G. J. and Peel, D. (2000)
<em>Finite Mixture Models</em>.
New York: Wiley.
</p>
<p>Everitt, B. S. and Hand, D. J. (1981)
<em>Finite Mixture Distributions</em>.
London: Chapman &amp; Hall.
</p>


<h3>See Also</h3>

<p><code><a href="uninormal.html">uninormal</a></code>,
<code><a href="../../stats/html/Normal.html">Normal</a></code>,
<code><a href="mix2poisson.html">mix2poisson</a></code>.
</p>


<h3>Examples</h3>

<pre>
## Not run:  mu1 &lt;-  99; mu2 &lt;- 150; nn &lt;- 1000
sd1 &lt;- sd2 &lt;- exp(3)
(phi &lt;- logit(-1, inverse = TRUE))
mdata &lt;- data.frame(y = ifelse(runif(nn) &lt; phi, rnorm(nn, mu1, sd1),
                                                rnorm(nn, mu2, sd2)))
fit &lt;- vglm(y ~ 1, mix2normal(eq.sd = TRUE), data = mdata)

# Compare the results
cfit &lt;- coef(fit)
round(rbind('Estimated' = c(logit(cfit[1], inverse = TRUE),
            cfit[2], exp(cfit[3]), cfit[4]),
            'Truth' = c(phi, mu1, sd1, mu2)), digits = 2)

# Plot the results
xx &lt;- with(mdata, seq(min(y), max(y), len = 200))
plot(xx, (1-phi) * dnorm(xx, mu2, sd2), type = "l", xlab = "y",
     main = "Orange = estimate, blue = truth",
     col = "blue", ylab = "Density")
phi.est &lt;- logit(coef(fit)[1], inverse = TRUE)
sd.est &lt;- exp(coef(fit)[3])
lines(xx, phi*dnorm(xx, mu1, sd1), col = "blue")
lines(xx, phi.est * dnorm(xx, Coef(fit)[2], sd.est), col = "orange")
lines(xx, (1-phi.est) * dnorm(xx, Coef(fit)[4], sd.est), col = "orange")
abline(v = Coef(fit)[c(2,4)], lty = 2, col = "orange")
abline(v = c(mu1, mu2), lty = 2, col = "blue")

## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>VGAM</em> version 1.0-2 <a href="00Index.html">Index</a>]</div>
</body></html>
