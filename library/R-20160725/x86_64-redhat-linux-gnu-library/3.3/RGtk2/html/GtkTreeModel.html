<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: GtkTreeModel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for GtkTreeModel {RGtk2}"><tr><td>GtkTreeModel {RGtk2}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>GtkTreeModel</h2>

<h3>Description</h3>

<p>The tree interface used by GtkTreeView</p>


<h3>Methods and Functions</h3>

<p><code><a href="gtkTreePathNew.html">gtkTreePathNew</a>()</code><br />
<code><a href="gtkTreePathNewFromString.html">gtkTreePathNewFromString</a>(path)</code><br />
<code><a href="gtkTreePathNewFromIndices.html">gtkTreePathNewFromIndices</a>(...)</code><br />
<code><a href="gtkTreePathToString.html">gtkTreePathToString</a>(object)</code><br />
<code><a href="gtkTreePathNewFirst.html">gtkTreePathNewFirst</a>()</code><br />
<code><a href="gtkTreePathAppendIndex.html">gtkTreePathAppendIndex</a>(object, index)</code><br />
<code><a href="gtkTreePathPrependIndex.html">gtkTreePathPrependIndex</a>(object, index)</code><br />
<code><a href="gtkTreePathGetDepth.html">gtkTreePathGetDepth</a>(object)</code><br />
<code><a href="gtkTreePathGetIndices.html">gtkTreePathGetIndices</a>(object)</code><br />
<code><a href="gtkTreePathCopy.html">gtkTreePathCopy</a>(object)</code><br />
<code><a href="gtkTreePathCompare.html">gtkTreePathCompare</a>(object, b)</code><br />
<code><a href="gtkTreePathNext.html">gtkTreePathNext</a>(object)</code><br />
<code><a href="gtkTreePathPrev.html">gtkTreePathPrev</a>(object)</code><br />
<code><a href="gtkTreePathUp.html">gtkTreePathUp</a>(object)</code><br />
<code><a href="gtkTreePathDown.html">gtkTreePathDown</a>(object)</code><br />
<code><a href="gtkTreePathIsAncestor.html">gtkTreePathIsAncestor</a>(object, descendant)</code><br />
<code><a href="gtkTreePathIsDescendant.html">gtkTreePathIsDescendant</a>(object, ancestor)</code><br />
<code><a href="gtkTreeRowReferenceNew.html">gtkTreeRowReferenceNew</a>(model, path)</code><br />
<code><a href="gtkTreeRowReferenceNewProxy.html">gtkTreeRowReferenceNewProxy</a>(proxy, model, path)</code><br />
<code><a href="gtkTreeRowReferenceGetModel.html">gtkTreeRowReferenceGetModel</a>(object)</code><br />
<code><a href="gtkTreeRowReferenceGetPath.html">gtkTreeRowReferenceGetPath</a>(object)</code><br />
<code><a href="gtkTreeRowReferenceValid.html">gtkTreeRowReferenceValid</a>(object)</code><br />
<code><a href="gtkTreeRowReferenceCopy.html">gtkTreeRowReferenceCopy</a>(object)</code><br />
<code><a href="gtkTreeRowReferenceInserted.html">gtkTreeRowReferenceInserted</a>(proxy, path)</code><br />
<code><a href="gtkTreeRowReferenceDeleted.html">gtkTreeRowReferenceDeleted</a>(proxy, path)</code><br />
<code><a href="gtkTreeRowReferenceReordered.html">gtkTreeRowReferenceReordered</a>(proxy, path, iter, new.order)</code><br />
<code><a href="gtkTreeIterCopy.html">gtkTreeIterCopy</a>(object)</code><br />
<code><a href="gtkTreeModelGetFlags.html">gtkTreeModelGetFlags</a>(object)</code><br />
<code><a href="gtkTreeModelGetNColumns.html">gtkTreeModelGetNColumns</a>(object)</code><br />
<code><a href="gtkTreeModelGetColumnType.html">gtkTreeModelGetColumnType</a>(object, index)</code><br />
<code><a href="gtkTreeModelGetIter.html">gtkTreeModelGetIter</a>(object, path)</code><br />
<code><a href="gtkTreeModelGetIterFromString.html">gtkTreeModelGetIterFromString</a>(object, path.string)</code><br />
<code><a href="gtkTreeModelGetIterFirst.html">gtkTreeModelGetIterFirst</a>(object)</code><br />
<code><a href="gtkTreeModelGetPath.html">gtkTreeModelGetPath</a>(object, iter)</code><br />
<code><a href="gtkTreeModelGetValue.html">gtkTreeModelGetValue</a>(object, iter, column)</code><br />
<code><a href="gtkTreeModelIterNext.html">gtkTreeModelIterNext</a>(object, iter)</code><br />
<code><a href="gtkTreeModelIterChildren.html">gtkTreeModelIterChildren</a>(object, parent = NULL)</code><br />
<code><a href="gtkTreeModelIterHasChild.html">gtkTreeModelIterHasChild</a>(object, iter)</code><br />
<code><a href="gtkTreeModelIterNChildren.html">gtkTreeModelIterNChildren</a>(object, iter = NULL)</code><br />
<code><a href="gtkTreeModelIterNthChild.html">gtkTreeModelIterNthChild</a>(object, parent = NULL, n)</code><br />
<code><a href="gtkTreeModelIterParent.html">gtkTreeModelIterParent</a>(object, child)</code><br />
<code><a href="gtkTreeModelGetStringFromIter.html">gtkTreeModelGetStringFromIter</a>(object, iter)</code><br />
<code><a href="gtkTreeModelRefNode.html">gtkTreeModelRefNode</a>(object, iter)</code><br />
<code><a href="gtkTreeModelUnrefNode.html">gtkTreeModelUnrefNode</a>(object, iter)</code><br />
<code><a href="gtkTreeModelGet.html">gtkTreeModelGet</a>(object, iter, ...)</code><br />
<code><a href="gtkTreeModelForeach.html">gtkTreeModelForeach</a>(object, func, user.data = NULL)</code><br />
<code><a href="gtkTreeModelRowChanged.html">gtkTreeModelRowChanged</a>(object, path, iter)</code><br />
<code><a href="gtkTreeModelRowInserted.html">gtkTreeModelRowInserted</a>(object, path, iter)</code><br />
<code><a href="gtkTreeModelRowHasChildToggled.html">gtkTreeModelRowHasChildToggled</a>(object, path, iter)</code><br />
<code><a href="gtkTreeModelRowDeleted.html">gtkTreeModelRowDeleted</a>(object, path)</code><br />
<code><a href="gtkTreeModelRowsReordered.html">gtkTreeModelRowsReordered</a>(object, path, iter, new.order)</code><br />
</p>


<h3>Hierarchy</h3>

<pre>
GInterface
   +----GtkTreeModel
GBoxed
   +----GtkTreeIter
GBoxed
   +----GtkTreePath
</pre>

<h3>Implementations</h3>

<p>GtkTreeModel is implemented by
<code><a href="GtkListStore.html">GtkListStore</a></code>,  <code><a href="GtkTreeModelFilter.html">GtkTreeModelFilter</a></code>,  <code><a href="GtkTreeModelSort.html">GtkTreeModelSort</a></code> and  <code><a href="GtkTreeStore.html">GtkTreeStore</a></code>.</p>


<h3>Interface Derivations</h3>

<p>GtkTreeModel is required by
<code><a href="GtkTreeSortable.html">GtkTreeSortable</a></code>.</p>


<h3>Detailed Description</h3>

<p>The <code><a href="GtkTreeModel.html">GtkTreeModel</a></code> interface defines a generic tree interface for use by
the <code><a href="GtkTreeView.html">GtkTreeView</a></code> widget.  It is an abstract interface, and is designed
to be usable with any appropriate data structure.  The programmer just
has to implement this interface on their own data type for it to be
viewable by a <code><a href="GtkTreeView.html">GtkTreeView</a></code> widget.
</p>
<p>The model is represented as a hierarchical tree of strongly-typed,
columned data.  In other words, the model can be seen as a tree where
every node has different values depending on which column is being
queried.  The type of data found in a column is determined by using the
GType system (ie. <code style="white-space: pre;">G_TYPE_INT</code>, <code style="white-space: pre;">GTK_TYPE_BUTTON</code>, <code style="white-space: pre;">G_TYPE_POINTER</code>, etc.).
The types are homogeneous per column across all nodes.  It is important
to note that this interface only provides a way of examining a model and
observing changes.  The implementation of each individual model decides
how and if changes are made.
</p>
<p>In order to make life simpler for programmers who do not need to write
their own specialized model, two generic models are provided &ndash; the
<code><a href="GtkTreeStore.html">GtkTreeStore</a></code> and the <code><a href="GtkListStore.html">GtkListStore</a></code>.  To use these, the developer simply
pushes data into these models as necessary.  These models provide the
data structure as well as all appropriate tree interfaces.  As a result,
implementing drag and drop, sorting, and storing data is trivial.  For
the vast majority of trees and lists, these two models are sufficient.
</p>
<p>Models are accessed on a node/column level of granularity.  One can
query for the value of a model at a certain node and a certain column
on that node.  There are two structures used to reference a particular
node in a model.  They are the <code><a href="GtkTreeModel.html">GtkTreePath</a></code> and the <code><a href="GtkTreeModel.html">GtkTreeIter</a></code>
<strong>PLEASE NOTE:</strong> Here, <em>iter</em> is short for &ldquo;iterator&rdquo;
Most of the interface consists of operations on a <code><a href="GtkTreeModel.html">GtkTreeIter</a></code>.
</p>
<p>A path is essentially a potential node.  It is a location on a model
that may or may not actually correspond to a node on a specific model.
The <code><a href="GtkTreeModel.html">GtkTreePath</a></code> struct can be converted into either a list of
unsigned integers or a string.  The string form is a list of numbers
separated by a colon.  Each number refers to the offset at that level.
Thus, the path &ldquo;0&rdquo; refers to the root node and the path
&ldquo;2:4&rdquo; refers to the fifth child of the third node.
</p>
<p>By contrast, a <code><a href="GtkTreeModel.html">GtkTreeIter</a></code> is a reference to a specific node on a
specific model.  It is a generic struct with an integer and three
generic pointers.  These are filled in by the model in a model-specific
way.  One can convert a path to an iterator by calling
<code><a href="gtkTreeModelGetIter.html">gtkTreeModelGetIter</a></code>.  These iterators are the primary way of
accessing a model and are similar to the iterators used by
<code><a href="GtkTextBuffer.html">GtkTextBuffer</a></code>.  They are generally statically allocated on the stack and
only used for a short time.  The model interface defines a set of
operations using them for navigating the model.
</p>
<p>It is expected that models fill in the iterator with private data.  For
example, the <code><a href="GtkListStore.html">GtkListStore</a></code> model, which is internally a simple linked
list, stores a list node in one of the pointers.  The <code><a href="GtkTreeModelSort.html">GtkTreeModelSort</a></code>
stores a list and an offset in two of the pointers.  Additionally,
there is an integer field.  This field is generally filled with a unique
stamp per model.  This stamp is for catching errors resulting from using
invalid iterators with a model.
</p>
<p>The lifecycle of an iterator can be a little confusing at first.
Iterators are expected to always be valid for as long as the model is
unchanged (and doesn't emit a signal).  The model is considered to own
all outstanding iterators and nothing needs to be done to free them from
the user's point of view.  Additionally, some models guarantee that an
iterator is valid for as long as the node it refers to is valid (most
notably the <code><a href="GtkTreeStore.html">GtkTreeStore</a></code> and <code><a href="GtkListStore.html">GtkListStore</a></code>).  Although generally
uninteresting, as one always has to allow for the case where iterators
do not persist beyond a signal, some very important performance
enhancements were made in the sort model.  As a result, the
<code style="white-space: pre;">GTK_TREE_MODEL_ITERS_PERSIST</code> flag was added to indicate this behavior.
</p>
<p>To help show some common operation of a model, some examples are
provided.  The first example shows three ways of getting the iter at the
location &ldquo;3:2:5&rdquo;.  While the first method shown is easier,
the second is much more common, as you often get paths from callbacks.
</p>
<p><em>Acquiring a   <code>GtkTreeIter</code></em>
</p>
<pre>
## Acquiring a GtkTreeIter

## Three ways of getting the iter pointing to the location

## get the iterator from a string 
model$getIterFromString("3:2:5")$iter

## get the iterator from a path
path &lt;- gtkTreePathNewFromString("3:2:5")
model$getIter(path)$iter

## walk the tree to find the iterator
parent_iter &lt;- model$iterNthChild(NULL, 3)$iter
parent_iter &lt;- model$iterNthChild(parent_iter, 2)$iter
model$iterNthChild(parent_iter, 5)$iter
</pre>  
<p>This second example shows a quick way of iterating through a list and
getting a string and an integer from each row.  The
<code>populateModel</code> function used below is not shown, as
it is specific to the <code><a href="GtkListStore.html">GtkListStore</a></code>.  For information on how to write
such a function, see the <code><a href="GtkListStore.html">GtkListStore</a></code> documentation.
</p>
<p><em>Reading data from a   <code>GtkTreeModel</code></em>
</p>
<pre>
## Reading data from a GtkTreeModel

## make a new list_store
list_store &lt;- gtkListStore("character", "integer")

## Fill the list store with data
populate_model(list_store)

## Get the first iter in the list 
result &lt;- list_store$getIterFirst()

row_count &lt;- 1
while(result[[1]]) {
  ## Walk through the list, reading each row
      
  data &lt;- list_store$get(result$iter, 0, 1)
  
  ## Do something with the data
  print(paste("Row ", row_count, ": (", data[[1]], ",", data[[2]], ")", sep=""))
  
  row_count &lt;- row_count + 1
  result &lt;- list_store$iterNext()
}
</pre>

<h3>Structures</h3>


<dl>
<dt><code style="white-space: pre;">GtkTreeModel</code></dt><dd>
<p><em>undocumented
</em>
</p>
</dd>
<dt><code style="white-space: pre;">GtkTreeIter</code></dt><dd>
<p>The <code>GtkTreeIter</code> is the primary structure for
accessing a structure.  Models are expected to put a unique integer in
the <code>stamp</code> member, and put model-specific
data in the three <code>user_data</code> members.
</p>
</dd>
<dt><code style="white-space: pre;">GtkTreePath</code></dt><dd>
<p><em>undocumented
</em>
</p>
</dd>
<dt><code style="white-space: pre;">GtkTreeRowReference</code></dt><dd>
<p><em>undocumented
</em>
</p>
</dd>
</dl>


<h3>Enums and Flags</h3>

<dl>
<dt><code style="white-space: pre;">GtkTreeModelFlags</code></dt><dd>
<p>These flags indicate various properties of a <code><a href="GtkTreeModel.html">GtkTreeModel</a></code>.  They are
returned by <code><a href="gtkTreeModelGetFlags.html">gtkTreeModelGetFlags</a></code>, and must be static for the
lifetime of the object.  A more complete description of
<code style="white-space: pre;">GTK_TREE_MODEL_ITERS_PERSIST</code> can be found in the overview of this
section.
</p>

<dl>
<dt><code style="white-space: pre;">iters-persist</code></dt><dd><p>Iterators survive all signals emitted by the tree.</p>
</dd>
<dt><code style="white-space: pre;">list-only</code></dt><dd><p>The model is a list only, and never has children</p>
</dd>
</dl>

</dd></dl>


<h3>User Functions</h3>

<dl>
<dt><code>GtkTreeModelForeachFunc(model, path, iter, data)</code></dt><dd>
<p><em>undocumented
</em>
</p>

<dl>
<dt><code>model</code></dt><dd><p>The <code><a href="GtkTreeModel.html">GtkTreeModel</a></code> currently being iterated</p>
</dd>
<dt><code>path</code></dt><dd><p>The current <code><a href="GtkTreeModel.html">GtkTreePath</a></code></p>
</dd>
<dt><code>iter</code></dt><dd><p>The current <code><a href="GtkTreeModel.html">GtkTreeIter</a></code></p>
</dd>
<dt><code>data</code></dt><dd><p>The user data passed to <code><a href="gtkTreeModelForeach.html">gtkTreeModelForeach</a></code></p>
</dd>
</dl>

<p><em>Returns:</em> [logical] <code>TRUE</code> to stop iterating, <code>FALSE</code> to continue.
</p>
</dd></dl>


<h3>Signals</h3>


<dl>
<dt><code>row-changed(tree.model, path, iter, user.data)</code></dt><dd>
<p>This signal is emitted when a row in the model has changed.
</p>

<dl>
<dt><code>tree.model</code></dt><dd><p>the <code><a href="GtkTreeModel.html">GtkTreeModel</a></code> on which the signal is emitted</p>
</dd>
<dt><code>path</code></dt><dd><p>a <code><a href="GtkTreeModel.html">GtkTreePath</a></code> identifying the changed row</p>
</dd>
<dt><code>iter</code></dt><dd><p>a valid <code><a href="GtkTreeModel.html">GtkTreeIter</a></code> pointing to the changed row</p>
</dd>
<dt><code>user.data</code></dt><dd><p>user data set when the signal handler was connected.</p>
</dd>
</dl>

</dd>
<dt><code>row-deleted(tree.model, path, user.data)</code></dt><dd>
<p>This signal is emitted when a row has been deleted.
</p>
<p>Note that no iterator is passed to the signal handler,
since the row is already deleted.
</p>
<p>Implementations of GtkTreeModel must emit row-deleted
<em>before</em> removing the node from its
internal data structures.  This is because models and
views which access and monitor this model might have
references on the node which need to be released in the
row-deleted handler.
</p>

<dl>
<dt><code>tree.model</code></dt><dd><p>the <code><a href="GtkTreeModel.html">GtkTreeModel</a></code> on which the signal is emitted</p>
</dd>
<dt><code>path</code></dt><dd><p>a <code><a href="GtkTreeModel.html">GtkTreePath</a></code> identifying the row</p>
</dd>
<dt><code>user.data</code></dt><dd><p>user data set when the signal handler was connected.</p>
</dd>
</dl>

</dd>
<dt><code>row-has-child-toggled(tree.model, path, iter, user.data)</code></dt><dd>
<p>This signal is emitted when a row has gotten the first child row or lost
its last child row.
</p>

<dl>
<dt><code>tree.model</code></dt><dd><p>the <code><a href="GtkTreeModel.html">GtkTreeModel</a></code> on which the signal is emitted</p>
</dd>
<dt><code>path</code></dt><dd><p>a <code><a href="GtkTreeModel.html">GtkTreePath</a></code> identifying the row</p>
</dd>
<dt><code>iter</code></dt><dd><p>a valid <code><a href="GtkTreeModel.html">GtkTreeIter</a></code> pointing to the row</p>
</dd>
<dt><code>user.data</code></dt><dd><p>user data set when the signal handler was connected.</p>
</dd>
</dl>

</dd>
<dt><code>row-inserted(tree.model, path, iter, user.data)</code></dt><dd>
<p>This signal is emitted when a new row has been inserted in the model.
</p>
<p>Note that the row may still be empty at this point, since
it is a common pattern to first insert an empty row, and
then fill it with the desired values.
</p>

<dl>
<dt><code>tree.model</code></dt><dd><p>the <code><a href="GtkTreeModel.html">GtkTreeModel</a></code> on which the signal is emitted</p>
</dd>
<dt><code>path</code></dt><dd><p>a <code><a href="GtkTreeModel.html">GtkTreePath</a></code> identifying the new row</p>
</dd>
<dt><code>iter</code></dt><dd><p>a valid <code><a href="GtkTreeModel.html">GtkTreeIter</a></code> pointing to the new row</p>
</dd>
<dt><code>user.data</code></dt><dd><p>user data set when the signal handler was connected.</p>
</dd>
</dl>

</dd>
<dt><code>rows-reordered(tree.model, path, iter, new.order, user.data)</code></dt><dd>
<p>This signal is emitted when the children of a node in the <code><a href="GtkTreeModel.html">GtkTreeModel</a></code>
have been reordered.
</p>
<p>Note that this signal is <em>not</em> emitted
when rows are reordered by DND, since this is implemented
by removing and then reinserting the row.
</p>

<dl>
<dt><code>tree.model</code></dt><dd><p>the <code><a href="GtkTreeModel.html">GtkTreeModel</a></code> on which the signal is emitted</p>
</dd>
<dt><code>path</code></dt><dd><p>a <code><a href="GtkTreeModel.html">GtkTreePath</a></code> identifying the tree node whose children
have been reordered</p>
</dd>
<dt><code>iter</code></dt><dd><p>a valid <code><a href="GtkTreeModel.html">GtkTreeIter</a></code> pointing to the node whose</p>
</dd>
<dt><code>new.order</code></dt><dd><p>a list of integers mapping the current position of
each child to its old position before the re-ordering,
i.e. <code>new.order</code><code>[newpos] = oldpos</code>.</p>
</dd>
<dt><code>user.data</code></dt><dd><p>user data set when the signal handler was connected.</p>
</dd>
</dl>

</dd>
</dl>


<h3>Author(s)</h3>

<p>Derived by RGtkGen from GTK+ documentation</p>


<h3>References</h3>

<p><a href="http://library.gnome.org/devel//gtk/GtkTreeModel.html">http://library.gnome.org/devel//gtk/GtkTreeModel.html</a></p>


<h3>See Also</h3>

<p><code><a href="GtkTreeView.html">GtkTreeView</a></code>
<code><a href="GtkTreeStore.html">GtkTreeStore</a></code>
<code><a href="GtkListStore.html">GtkListStore</a></code>
<code><a href="GtkTreeSortable.html">GtkTreeSortable</a></code>
</p>

<hr /><div style="text-align: center;">[Package <em>RGtk2</em> version 2.20.31 <a href="00Index.html">Index</a>]</div>
</body></html>
