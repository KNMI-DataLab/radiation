<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Create and train a self-organizing map (SOM)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for som {RSNNS}"><tr><td>som {RSNNS}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Create and train a self-organizing map (SOM)</h2>

<h3>Description</h3>

<p>This function creates and trains a self-organizing map (SOM).
SOMs are neural networks with one hidden layer.
The network structure is similar to LVQ, but the method is unsupervised
and uses a notion of neighborhood between the units.
The general idea is that the map develops by itself a notion of similarity among
the input and represents this as spatial nearness on the map.
Every hidden unit represents a prototype. The goal of learning is to
distribute the prototypes in the feature space such that the (probability
density of the) input is represented well.
SOMs are usually built with 1d, 2d quadratic, 2d hexagonal, or 3d
neighborhood, so that they can be visualized straightforwardly.
The SOM implemented in SNNS has a 2d quadratic neighborhood.
</p>


<h3>Usage</h3>

<pre>
som(x, ...)

## Default S3 method:
som(x, mapX = 16, mapY = 16, maxit = 100,
  initFuncParams = c(1, -1), learnFuncParams = c(0.5, mapX/2, 0.8, 0.8,
  mapX), updateFuncParams = c(0, 0, 1), shufflePatterns = TRUE,
  calculateMap = TRUE, calculateActMaps = FALSE,
  calculateSpanningTree = FALSE, saveWinnersPerPattern = FALSE,
  targets = NULL, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>a matrix with training inputs for the network</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>additional function parameters (currently not used)</p>
</td></tr>
<tr valign="top"><td><code>mapX</code></td>
<td>
<p>the x dimension of the som</p>
</td></tr>
<tr valign="top"><td><code>mapY</code></td>
<td>
<p>the y dimension of the som</p>
</td></tr>
<tr valign="top"><td><code>maxit</code></td>
<td>
<p>maximum of iterations to learn</p>
</td></tr>
<tr valign="top"><td><code>initFuncParams</code></td>
<td>
<p>the parameters for the initialization function</p>
</td></tr>
<tr valign="top"><td><code>learnFuncParams</code></td>
<td>
<p>the parameters for the learning function</p>
</td></tr>
<tr valign="top"><td><code>updateFuncParams</code></td>
<td>
<p>the parameters for the update function</p>
</td></tr>
<tr valign="top"><td><code>shufflePatterns</code></td>
<td>
<p>should the patterns be shuffled?</p>
</td></tr>
<tr valign="top"><td><code>calculateMap</code></td>
<td>
<p>should the som be calculated?</p>
</td></tr>
<tr valign="top"><td><code>calculateActMaps</code></td>
<td>
<p>should the activation maps be calculated?</p>
</td></tr>
<tr valign="top"><td><code>calculateSpanningTree</code></td>
<td>
<p>should the SNNS kernel algorithm for generating a spanning tree be applied?</p>
</td></tr>
<tr valign="top"><td><code>saveWinnersPerPattern</code></td>
<td>
<p>should a list with the winners for every pattern be saved?</p>
</td></tr>
<tr valign="top"><td><code>targets</code></td>
<td>
<p>optional target classes of the patterns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As the computation of this function might be slow if many patterns are involved,
much of its output is made switchable (see comments on return values).
</p>
<p>Internally, this function uses the initialization function <code>Kohonen_Weights_v3.2</code>,
the learning function <code>Kohonen</code>, and the update function <code>Kohonen_Order</code> of
SNNS.
</p>


<h3>Value</h3>

<p>an <code><a href="rsnnsObjectFactory.html">rsnns</a></code> object. Depending on which calculation flags are
switched on, the som generates some special members:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>map</code></td>
<td>
<p>the som. For each unit, the amount of patterns where this unit won is given.</p>
</td></tr>
<tr valign="top"><td><code>componentMaps</code></td>
<td>
<p>a map for every input component, showing where in the map this component leads to high activation.</p>
</td></tr>
<tr valign="top"><td><code>actMaps</code></td>
<td>
<p>a list containing for each pattern its activation map, i.e. all unit activations.
The <code>actMaps</code> are an intermediary result, from which all other results can be computed. This list can be very long,
so normally it won't be saved.</p>
</td></tr>
<tr valign="top"><td><code>winnersPerPattern</code></td>
<td>
<p>a vector where for each pattern the number of the winning unit is given. Also, an intermediary result
that normally won't be saved.</p>
</td></tr>
<tr valign="top"><td><code>labeledUnits</code></td>
<td>
<p>a matrix which &ndash; if the <code>targets</code> parameter is given &ndash; contains for each unit (rows) and each class
present in the <code>targets</code> (columns), the amount of patterns of the class where the unit has won. From the <code>labeledUnits</code>,
the <code>labeledMap</code> can be computed, e.g. by voting of the class labels for the final label of the unit.</p>
</td></tr>
<tr valign="top"><td><code>labeledMap</code></td>
<td>
<p>a labeled som that is computed from <code>labeledUnits</code> using <code><a href="decodeClassLabels.html">decodeClassLabels</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>spanningTree</code></td>
<td>
<p>the result of the original SNNS function to calculate the map. For each unit, the last pattern where this unit won is present.
As the other results are more informative, the spanning tree is only interesting, if the other functions are too slow or if the original SNNS
implementation is needed.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kohonen, T. (1988), Self-organization and associative memory, Vol. 8, Springer-Verlag.
</p>
<p>Zell, A. et al. (1998), 'SNNS Stuttgart Neural Network Simulator User Manual, Version 4.2', IPVR, University of Stuttgart and WSI, University of TÃ¼bingen.
<a href="http://www.ra.cs.uni-tuebingen.de/SNNS/">http://www.ra.cs.uni-tuebingen.de/SNNS/</a>
</p>
<p>Zell, A. (1994), Simulation Neuronaler Netze, Addison-Wesley. (in German)
</p>


<h3>Examples</h3>

<pre>
## Not run: demo(som_iris)
## Not run: demo(som_cubeSnnsR)


data(iris)
inputs &lt;- normalizeData(iris[,1:4], "norm")

model &lt;- som(inputs, mapX=16, mapY=16, maxit=500,
                calculateActMaps=TRUE, targets=iris[,5])

par(mfrow=c(3,3))
for(i in 1:ncol(inputs)) plotActMap(model$componentMaps[[i]],
                                       col=rev(topo.colors(12)))

plotActMap(model$map, col=rev(heat.colors(12)))
plotActMap(log(model$map+1), col=rev(heat.colors(12)))
persp(1:model$archParams$mapX, 1:model$archParams$mapY, log(model$map+1),
     theta = 30, phi = 30, expand = 0.5, col = "lightblue")

plotActMap(model$labeledMap)

model$componentMaps
model$labeledUnits
model$map

names(model)
</pre>

<hr /><div style="text-align: center;">[Package <em>RSNNS</em> version 0.4-7 <a href="00Index.html">Index</a>]</div>
</body></html>
