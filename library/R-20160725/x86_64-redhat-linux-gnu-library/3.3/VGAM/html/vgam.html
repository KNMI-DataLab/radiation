<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Fitting Vector Generalized Additive Models</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for vgam {VGAM}"><tr><td>vgam {VGAM}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2> Fitting Vector Generalized Additive Models </h2>

<h3>Description</h3>

<p>Fit a vector generalized additive model (VGAM).  This is a large class
of models that includes generalized additive models (GAMs) and vector
generalized linear models (VGLMs) as special cases.
</p>


<h3>Usage</h3>

<pre>
vgam(formula, family, data = list(), weights = NULL, subset = NULL, 
     na.action = na.fail, etastart = NULL, mustart = NULL, 
     coefstart = NULL, control = vgam.control(...), offset = NULL, 
     method = "vgam.fit", model = FALSE, x.arg = TRUE, y.arg = TRUE, 
     contrasts = NULL, constraints = NULL, 
     extra = list(), form2 = NULL, qr.arg = FALSE, smart = TRUE, ...)
</pre>


<h3>Arguments</h3>


<table summary="R argblock">
<tr valign="top"><td><code>formula</code></td>
<td>

<p>a symbolic description of the model to be fit.
The RHS of the formula is applied to each linear/additive predictor,
and usually includes at least one <code><a href="s.html">s</a></code> term.
Different variables in each linear/additive predictor
can be chosen by specifying constraint matrices.
</p>
</td></tr>
<tr valign="top"><td><code>family</code></td>
<td>

<p>Same as for <code><a href="vglm.html">vglm</a></code>.
</p>
</td></tr>
<tr valign="top"><td><code>data</code></td>
<td>

<p>an optional data frame containing the variables in the model.
By default the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>vgam</code> is called.
</p>
</td></tr>
<tr valign="top"><td><code>weights, subset, na.action</code></td>
<td>

<p>Same as for <code><a href="vglm.html">vglm</a></code>.
Note that <code>subset</code> may be unreliable and to get around
this problem it is best to use <code><a href="../../base/html/subset.html">subset</a></code> to create
a new smaller data frame and feed in the smaller data frame.
See below for an example.
This is a bug that needs fixing.
</p>
</td></tr>
<tr valign="top"><td><code>etastart, mustart, coefstart</code></td>
<td>

<p>Same as for <code><a href="vglm.html">vglm</a></code>.
</p>
</td></tr>
<tr valign="top"><td><code>control</code></td>
<td>

<p>a list of parameters for controlling the fitting process.
See <code><a href="vgam.control.html">vgam.control</a></code> for details.
</p>
</td></tr>
<tr valign="top"><td><code>method</code></td>
<td>

<p>the method to be used in fitting the model.
The default (and presently only) method <code>vgam.fit</code>
uses iteratively reweighted least squares (IRLS).
</p>
</td></tr>
<tr valign="top"><td><code>constraints, model, offset</code></td>
<td>

<p>Same as for <code><a href="vglm.html">vglm</a></code>.
</p>
</td></tr>
<tr valign="top"><td><code>x.arg, y.arg</code></td>
<td>

<p>logical values indicating whether the model matrix and response
vector/matrix used in the fitting process should be assigned in the
<code>x</code> and <code>y</code> slots.  Note the model matrix is the LM model
matrix; to get the VGAM model matrix type <code>model.matrix(vgamfit)</code>
where <code>vgamfit</code> is a <code>vgam</code> object.
</p>
</td></tr>
<tr valign="top"><td><code>contrasts, extra, form2, qr.arg, smart</code></td>
<td>

<p>Same as for <code><a href="vglm.html">vglm</a></code>.
</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>

<p>further arguments passed into <code><a href="vgam.control.html">vgam.control</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A vector generalized additive model (VGAM) is loosely defined
as a statistical model that is a function of <i>M</i> additive predictors.
The central formula is given by
</p>
<p style="text-align: center;"><i>
         eta_j = sum_{k=1}^p f_{(j)k}(x_k)</i></p>

<p>where <i>x_k</i> is the <i>k</i>th explanatory variable
(almost always <i>x_1=1</i> for the intercept term),
and
<i>f_{(j)k}</i> are smooth functions of <i>x_k</i> that are estimated
by smoothers. The first term in the summation is just the intercept.
Currently only one type of smoother is
implemented and this is called a <em>vector (cubic smoothing spline)
smoother</em>.
Here, <i>j=1,&hellip;,M</i> where <i>M</i> is finite.
If all the functions are constrained to be linear then
the resulting model is a vector generalized linear model
(VGLM).  VGLMs are best fitted with <code><a href="vglm.html">vglm</a></code>.
</p>
<p>Vector (cubic smoothing spline) smoothers are represented
by <code>s()</code> (see <code><a href="s.html">s</a></code>). Local
regression via <code>lo()</code> is <em>not</em> supported. The
results of <code>vgam</code> will differ from the <code>gam()</code>
(in the <span class="pkg">gam</span>) because <code>vgam()</code> uses a different
knot selection algorithm. In general, fewer knots are
chosen because the computation becomes expensive when
the number of additive predictors <i>M</i> is large.
</p>
<p>The underlying algorithm of VGAMs is iteratively
reweighted least squares (IRLS) and modified vector backfitting
using vector splines. B-splines are used as the basis functions
for the vector (smoothing) splines. 
<code>vgam.fit()</code> is the function that actually does the
work.  The smoothing code is based on F. O'Sullivan's
BART code.
</p>


<p>A closely related methodology based on VGAMs called
<em>constrained additive ordination</em> (CAO) first forms
a linear combination of the explanatory variables (called
<em>latent variables</em>) and then fits a GAM to these.
This is implemented in the function <code><a href="cao.html">cao</a></code>
for a very limited choice of family functions.
</p>


<h3>Value</h3>

<p>An object of class <code>"vgam"</code>
(see <code><a href="vgam-class.html">vgam-class</a></code> for further information). 
</p>


<h3>WARNING</h3>

<p>Currently <code>vgam</code> can only handle constraint matrices <code>cmat</code>,
say, such that <code>crossprod(cmat)</code> is diagonal.
This is a bug that I will try to fix up soon;
see <code><a href="is.buggy.html">is.buggy</a></code>.
</p>
<p>See warnings in <code><a href="vglm.control.html">vglm.control</a></code>.
</p>


<h3>Note</h3>

<p>This function can fit a wide variety of statistical models. Some of
these are harder to fit than others because of inherent numerical
difficulties associated with some of them. Successful model fitting
benefits from cumulative experience. Varying the values of arguments
in the <span class="pkg">VGAM</span> family function itself is a good first step if
difficulties arise, especially if initial values can be inputted.
A second, more general step, is to vary the values of arguments in
<code><a href="vgam.control.html">vgam.control</a></code>.
A third step is to make use of arguments such as <code>etastart</code>,
<code>coefstart</code> and <code>mustart</code>.
</p>
<p>Some <span class="pkg">VGAM</span> family functions end in <code>"ff"</code>
to avoid interference with other functions, e.g.,
<code><a href="binomialff.html">binomialff</a></code>, <code><a href="poissonff.html">poissonff</a></code>,
<code><a href="gaussianff.html">gaussianff</a></code>, <code>gammaff</code>. This is
because <span class="pkg">VGAM</span> family functions are incompatible with
<code><a href="../../stats/html/glm.html">glm</a></code> (and also <code><a href="../../gam/html/gam.html">gam</a></code>
in the <span class="pkg">gam</span> library and <code><a href="../../mgcv/html/gam.html">gam</a></code>
in the <span class="pkg">mgcv</span> library).
</p>
<p>The smart prediction (<code><a href="smartpred.html">smartpred</a></code>) library
is packed with the <span class="pkg">VGAM</span> library.
</p>
<p>The theory behind the scaling parameter is currently being
made more rigorous, but it it should give the same value
as the scale parameter for GLMs.
</p>


<h3>Author(s)</h3>

<p> Thomas W. Yee </p>


<h3>References</h3>

 
<p>Yee, T. W. and Wild, C. J. (1996)
Vector generalized additive models.
<em>Journal of the Royal Statistical Society, Series B, Methodological</em>,
<b>58</b>, 481&ndash;493.
</p>
<p>Yee, T. W. (2008)
The <code>VGAM</code> Package.
<em>R News</em>, <b>8</b>, 28&ndash;39.
</p>









<h3>See Also</h3>

<p><code><a href="is.buggy.html">is.buggy</a></code>,
<code><a href="vgam.control.html">vgam.control</a></code>,
<code><a href="vgam-class.html">vgam-class</a></code>,
<code><a href="vglmff-class.html">vglmff-class</a></code>,
<code><a href="plotvgam.html">plotvgam</a></code>,
<code><a href="vglm.html">vglm</a></code>,
<code><a href="s.html">s</a></code>,
<code><a href="vsmooth.spline.html">vsmooth.spline</a></code>,
<code><a href="cao.html">cao</a></code>.
</p>




<h3>Examples</h3>

<pre> # Nonparametric proportional odds model 
pneumo &lt;- transform(pneumo, let = log(exposure.time))
vgam(cbind(normal, mild, severe) ~ s(let),
     cumulative(parallel = TRUE), data = pneumo, trace = TRUE)

# Nonparametric logistic regression 
fit &lt;- vgam(agaaus ~ s(altitude, df = 2), binomialff, data = hunua)
## Not run:  plot(fit, se = TRUE) 
pfit &lt;- predict(fit, type = "terms", raw = TRUE, se = TRUE)
names(pfit)
head(pfit$fitted)
head(pfit$se.fit)
pfit$df
pfit$sigma

# Fit two species simultaneously 
fit2 &lt;- vgam(cbind(agaaus, kniexc) ~ s(altitude, df = c(2, 3)),
             binomialff(multiple.responses = TRUE), data = hunua)
coef(fit2, matrix = TRUE)  # Not really interpretable 
## Not run:  plot(fit2, se = TRUE, overlay = TRUE, lcol = 3:4, scol = 3:4)

ooo &lt;- with(hunua, order(altitude))
with(hunua, matplot(altitude[ooo], fitted(fit2)[ooo,], ylim = c(0, 0.8),
     xlab = "Altitude (m)", ylab = "Probability of presence", las = 1,
     main = "Two plant species' response curves", type = "l", lwd = 2))
with(hunua, rug(altitude)) 
## End(Not run)

# The subset argument does not work here. Use subset() instead.
set.seed(1)
zdata &lt;- data.frame(x2 = runif(nn &lt;- 100))
zdata &lt;- transform(zdata, y = rbinom(nn, 1, 0.5))
zdata &lt;- transform(zdata, subS = runif(nn) &lt; 0.7)
sub.zdata &lt;- subset(zdata, subS)  # Use this instead
if (FALSE)
  fit4a &lt;- vgam(cbind(y, y) ~ s(x2, df = 2),
                binomialff(multiple.responses = TRUE), 
                data = zdata, subset = subS)  # This fails!!!
fit4b &lt;- vgam(cbind(y, y) ~ s(x2, df = 2),
              binomialff(multiple.responses = TRUE), 
              data = sub.zdata)  # This succeeds!!!
</pre>

<hr /><div style="text-align: center;">[Package <em>VGAM</em> version 1.0-2 <a href="00Index.html">Index</a>]</div>
</body></html>
