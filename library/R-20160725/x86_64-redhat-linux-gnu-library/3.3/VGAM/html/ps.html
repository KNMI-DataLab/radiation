<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Defining Penalized Spline Smooths in VGAM Formulas</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for ps {VGAM}"><tr><td>ps {VGAM}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2> Defining Penalized Spline Smooths in VGAM Formulas </h2>

<h3>Description</h3>

<p><code>ps</code> is used in the definition of P-spline smooth terms within
<code>vgam</code> formulas.
</p>


<h3>Usage</h3>

<pre>
ps(x, ..., ps.intervals = NULL, lambda = 0, degree = 2,
   order = 2, ridge.adj = 1e-5, ridge.inv = 0.0001,
   spillover = 0.01, maxlambda = 1e4)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>

<p>covariate (abscissae) to be smoothed.
Also called the regressor.
If the <code>xij</code> facility is used then more
covariates are needed in the <code>...</code> argument.
</p>

</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>

<p>Used to accommodate the other <i>M-1</i> covariates
when the <code>xij</code> facility is used.
See Section 3.4.4 of Yee (2015) for something very similar.
This argument, found in the second argument, means that
the other argument names must be fully specified if used,
e.g., <code>ps.intervals</code> and not <code>ps.int</code>.
See the example below.
In the example below,
the term in the main formula is 
<code>ps(gcost.air, gcost.trn, gcost.bus)</code>
and one might be tempted to use something like
<code>ps(gcost)</code> to represent that <code>xij</code> term.
However, this is not recommended because
<code>ps(gcost)</code> might not have the same number of columns
as <code>ps(gcost.air, gcost.trn, gcost.bus)</code> etc.
That is, it is best to select one of the diagonal elements
of the block matrix to represent that term.
</p>
</td></tr>
<tr valign="top"><td><code>ps.intervals</code></td>
<td>

<p>the number of equally-spaced B-spline intervals.
Note that the number of knots is equal to
<code>ps.intervals + 2*degree + 1</code>.
The default, signified by <code>NULL</code>, means that
<code>ceiling(1.5 * log(length(unique(x.index))))</code>
is used, where <code>x.index</code> is the combined data.
This is not guaranteed to work on every data set, and
it might change in the future.
</p>
</td></tr>
<tr valign="top"><td><code>lambda, maxlambda</code></td>
<td>

<p><code>maxlambda</code> are the
non-negative regularization parameters for difference penalty,
whose values should be less than <code>maxlambda</code>.
Can be a vector.   
</p>
</td></tr>
<tr valign="top"><td><code>degree</code></td>
<td>

<p>degree of B-spline basis. Usually this will be 2 or 3; and
the values 1 or 4 might possibly be used.
</p>
</td></tr>
<tr valign="top"><td><code>order</code></td>
<td>

<p>order of difference penalty (0 is the ridge penalty).
</p>
</td></tr>
<tr valign="top"><td><code>ridge.adj, ridge.inv</code></td>
<td>

<p>small positive numbers to stabilize
linear dependencies among B-spline bases.
</p>
</td></tr>
<tr valign="top"><td><code>spillover</code></td>
<td>

<p>small positive proportion of the range used on
the outside of the boundary values.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is currently used by <code><a href="vgam.html">vgam</a></code> to
allow automatic smoothing parameter selection based on
P-splines and minimizing an UBRE quantity.
It is recommended above <code><a href="s.html">s</a></code> also because backfitting
is not required.
</p>


<p>Unlike <code>s</code>, which is symbolic and does not perform any smoothing itself,
this function does compute the penalized spline when
used by <code><a href="vgam.html">vgam</a></code>.
When this function is used within <code><a href="vgam.html">vgam</a></code>, automatic
smoothing parameter selection is implemented by calling
<code><a href="../../mgcv/html/magic.html">magic</a></code> after the necessary link-ups are done.
</p>
<p>This function is smart; it can be used for smart prediction
(Section 18.6 of Yee (2015)).
</p>


<h3>Value</h3>

<p>A matrix with attributes that are (only) used by <code><a href="vgam.html">vgam</a></code>.
The number of rows of the matrix is <code>length(x)</code> and
the number of columns is <code>ps.intervals + degree - 1</code>.
</p>


<h3>Note</h3>

<p>This function is currently under development and
may change in the future.
In particular, the default for <code>ps.intervals</code> is
subject to change.
</p>


<h3>Author(s)</h3>

<p>B. D. Marx wrote the original function.
Subsequent edits were made by T. W. Yee and C. Somchit.
</p>


<h3>References</h3>

<p>Eilers, P. H. C. and Marx, B. D. (2002).
Generalized Linear Additive Smooth Structures.
<em>Journal of Computational and Graphical Statistics</em>,
<b>11</b>(4): 758&ndash;783.
</p>
<p>Marx, B. D. and Eilers, P. H. C. (1998).
Direct generalized linear modeling
with penalized likelihood.
<em>CSDA</em>, <b>28</b>(2): 193&ndash;209.
</p>
<p>Eilers, P. H. C. and Marx, B. D. (1996).
Flexible smoothing with B-splines
and penalties (with comments and rejoinder).
<em>Statistical Science</em>, <b>11</b>(2): 89&ndash;121.
</p>
<p>Wood, S. N. (2004).
Stable and efficient multiple smoothing parameter estimation
for generalized additive models.
<em>J. Amer. Statist. Assoc.</em>, <b>99</b>(467): 673&ndash;686.
</p>


<h3>See Also</h3>

<p><code><a href="vgam.html">vgam</a></code>,
<code><a href="s.html">s</a></code>,
<code><a href="smartpred.html">smartpred</a></code>,
<code><a href="is.smart.html">is.smart</a></code>,
<code><a href="../../splines/html/splineDesign.html">splineDesign</a></code>,
<code><a href="../../splines/html/bs.html">bs</a></code>,
<code><a href="../../mgcv/html/magic.html">magic</a></code>.
</p>


<h3>Examples</h3>

<pre>
ps(runif(10))
ps(runif(10), ps.intervals = 5)

## Not run: 
data("TravelMode", package = "AER")  # Need to install "AER" first
air.df &lt;- subset(TravelMode, mode == "air")  # Form 4 smaller data frames
bus.df &lt;- subset(TravelMode, mode == "bus")
trn.df &lt;- subset(TravelMode, mode == "train")
car.df &lt;- subset(TravelMode, mode == "car")
TravelMode2 &lt;- data.frame(income     = air.df$income,
                          wait.air   = air.df$wait  - car.df$wait,
                          wait.trn   = trn.df$wait  - car.df$wait,
                          wait.bus   = bus.df$wait  - car.df$wait,
                          gcost.air  = air.df$gcost - car.df$gcost,
                          gcost.trn  = trn.df$gcost - car.df$gcost,
                          gcost.bus  = bus.df$gcost - car.df$gcost,
                          wait       = air.df$wait)  # Value is unimportant
TravelMode2$mode &lt;- subset(TravelMode, choice == "yes")$mode  # The response
TravelMode2 &lt;- transform(TravelMode2, incom.air = income, incom.trn = 0,
                                      incom.bus = 0)
set.seed(1)
TravelMode2 &lt;- transform(TravelMode2,
                         junkx2 = runif(nrow(TravelMode2)))

tfit2 &lt;-
  vgam(mode ~ ps(gcost.air, gcost.trn, gcost.bus) + ns(junkx2, 4) +
              ps(incom.air, incom.trn, incom.bus) + wait ,
       crit = "coef",
       multinomial(parallel = FALSE ~ 1), data = TravelMode2,
       xij = list(ps(gcost.air, gcost.trn, gcost.bus) ~
                  ps(gcost.air, gcost.trn, gcost.bus) +
                  ps(gcost.trn, gcost.bus, gcost.air) +
                  ps(gcost.bus, gcost.air, gcost.trn),
                  ps(incom.air, incom.trn, incom.bus) ~
                  ps(incom.air, incom.trn, incom.bus) +
                  ps(incom.trn, incom.bus, incom.air) +
                  ps(incom.bus, incom.air, incom.trn),
                  wait   ~  wait.air +  wait.trn +  wait.bus),
       form2 = ~  ps(gcost.air, gcost.trn, gcost.bus) +
                  ps(gcost.trn, gcost.bus, gcost.air) +
                  ps(gcost.bus, gcost.air, gcost.trn) +
                  wait +
                  ps(incom.air, incom.trn, incom.bus) +
                  ps(incom.trn, incom.bus, incom.air) +
                  ps(incom.bus, incom.air, incom.trn) +
                  junkx2 + ns(junkx2, 4) +
                  incom.air + incom.trn + incom.bus +
                  gcost.air + gcost.trn + gcost.bus +
                  wait.air +  wait.trn +  wait.bus)
par(mfrow = c(2, 2))
plot(tfit2, se = TRUE, lcol = "orange", scol = "blue", ylim = c(-4, 4))

## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>VGAM</em> version 1.0-2 <a href="00Index.html">Index</a>]</div>
</body></html>
