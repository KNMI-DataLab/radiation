<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Class &quot;gpc.poly&quot;</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for gpc.poly-class {rgeos}"><tr><td>gpc.poly-class {rgeos}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Class &quot;gpc.poly&quot;</h2>

<h3>Description</h3>

<p>A class for representing polygons composed of multiple contours, some
of which may be holes.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("gpc.poly",
    ...)</code> or by reading in from a file using <code>read.polyfile</code>.
</p>


<h3>Slots</h3>


<dl>
<dt>pts</dt><dd><p>Object of class &ldquo;list&rdquo;.  Actually,
<code>pts</code> is a list of lists with length equal to the number of
contours in the <code>"gpc.poly"</code> object.  Each element of
<code>pts</code> is a list of length 3 with names <code>x</code>, <code>y</code>,
and <code>hole</code>.  <code>x</code> and <code>y</code> are vectors containing the
x and y coordinates, respectively, while <code>hole</code> is a logical
indicating whether or not the contour is a hole.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "gpc.poly")</code>: ... </p>
</dd>
<dt>append.poly</dt><dd><p><code>signature(x = "gpc.poly", y = "gpc.poly")</code>: ... </p>
</dd>
<dt>area.poly</dt><dd><p><code>signature(object = "gpc.poly")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "matrix", to = "gpc.poly")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "data.frame", to = "gpc.poly")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "numeric", to = "gpc.poly")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "list", to = "gpc.poly")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "SpatialPolygons", to = "gpc.poly")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "gpc.poly", to = "matrix")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "gpc.poly", to = "numeric")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "gpc.poly", to = "SpatialPolygons")</code>: ... </p>
</dd>
<dt>get.bbox</dt><dd><p><code>signature(x = "gpc.poly")</code>: ... </p>
</dd>
<dt>get.pts</dt><dd><p><code>signature(object = "gpc.poly")</code>: ... </p>
</dd>
<dt>intersect</dt><dd><p><code>signature(x = "gpc.poly", y = "gpc.poly")</code>: ... </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "gpc.poly")</code>: The argument
<code>poly.args</code> can be used to pass a list of additional
arguments to be passed to the underlying <code>polygon</code> call.</p>
</dd>
<dt>scale.poly</dt><dd><p><code>signature(x = "gpc.poly")</code>: ... </p>
</dd>
<dt>setdiff</dt><dd><p><code>signature(x = "gpc.poly", y = "gpc.poly")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "gpc.poly")</code>: Scale x and y
coordinates by amount <code>xscale</code> and <code>yscale</code>.  By default
<code>xscale</code> equals <code>yscale</code>.</p>
</dd>
<dt>symdiff</dt><dd><p><code>signature(x = "gpc.poly", y = "gpc.poly")</code>: ... </p>
</dd>
<dt>union</dt><dd><p><code>signature(x = "gpc.poly", y = "gpc.poly")</code>: ... </p>
</dd>
<dt>tristrip</dt><dd><p><code>signature(x = "gpc.poly")</code>: ... </p>
</dd>
<dt>triangulate</dt><dd><p><code>signature(x = "gpc.poly")</code>: ... </p>
</dd>
</dl>



<h3>Note</h3>

<p>The class <code>"gpc.poly.nohole"</code> is identical to
<code>"gpc.poly"</code> except the <code>hole</code> flag for each contour of a
<code>"gpc.poly.nohole"</code> object is always <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Roger D. Peng</p>


<h3>Examples</h3>

<pre>
## Make some random polygons
set.seed(100)
a &lt;- cbind(rnorm(100), rnorm(100))
a &lt;- a[chull(a), ]

## Convert `a' from matrix to "gpc.poly"
a &lt;- as(a, "gpc.poly")

b &lt;- cbind(rnorm(100), rnorm(100))
b &lt;- as(b[chull(b), ], "gpc.poly")

## More complex polygons with an intersection
p1 &lt;- read.polyfile(system.file("poly-ex-gpc/ex-poly1.txt", package = "rgeos"))
p2 &lt;- read.polyfile(system.file("poly-ex-gpc/ex-poly2.txt", package = "rgeos"))

## Plot both polygons and highlight their intersection in red
plot(append.poly(p1, p2))
plot(intersect(p1, p2), poly.args = list(col = 2), add = TRUE)

## Highlight the difference p1 \ p2 in green
plot(setdiff(p1, p2), poly.args = list(col = 3), add = TRUE)

## Highlight the difference p2 \ p1 in blue
plot(setdiff(p2, p1), poly.args = list(col = 4), add = TRUE)

## Plot the union of the two polygons
plot(union(p1, p2))

## Take the non-intersect portions and create a new polygon
## combining the two contours
p.comb &lt;- append.poly(setdiff(p1, p2), setdiff(p2, p1))
plot(p.comb, poly.args = list(col = 2, border = 0))

## Coerce from a matrix
x &lt;- 
structure(c(0.0934073560027759, 0.192713393476752, 0.410062456627342, 
0.470020818875781, 0.41380985426787, 0.271408743927828, 0.100902151283831, 
0.0465648854961832, 0.63981588032221, 0.772382048331416,
0.753739930955121, 0.637744533947066, 0.455466052934407,
0.335327963176065, 0.399539700805524, 
0.600460299194476), .Dim = c(8, 2))
y &lt;- 
structure(c(0.404441360166551, 0.338861901457321, 0.301387925052047, 
0.404441360166551, 0.531852879944483, 0.60117973629424, 0.625537820957668, 
0.179976985040276, 0.341542002301496, 0.445109321058688,
0.610817031070196, 0.596317606444189, 0.459608745684695,
0.215189873417722), .Dim = c(7, 2))

x1 &lt;- as(x, "gpc.poly")
y1 &lt;- as(y, "gpc.poly")

plot(append.poly(x1, y1))
plot(intersect(x1, y1), poly.args = list(col = 2), add = TRUE)

## Show the triangulation
#plot(append.poly(x1, y1))
#triangles &lt;- triangulate(append.poly(x1,y1))
#for (i in 0:(nrow(triangles)/3 - 1)) 
#    polygon(triangles[3*i + 1:3,], col="lightblue")


</pre>

<hr /><div style="text-align: center;">[Package <em>rgeos</em> version 0.3-20 <a href="00Index.html">Index</a>]</div>
</body></html>
