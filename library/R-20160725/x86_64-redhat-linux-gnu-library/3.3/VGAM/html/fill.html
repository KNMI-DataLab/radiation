<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Creates a Matrix of Appropriate Dimension</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for fill {VGAM}"><tr><td>fill {VGAM}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2> Creates a Matrix of Appropriate Dimension </h2>

<h3>Description</h3>

<p>A support function for the argument <code>xij</code>, it generates a matrix
of an appropriate dimension.
</p>


<h3>Usage</h3>

<pre>
fill(x, values = 0, ncolx = ncol(x))
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>

<p>A vector or matrix which is used to determine the dimension of the
answer, in particular, the number of rows.  After converting <code>x</code>
to a matrix if necessary, the answer is a matrix of <code>values</code>
values, of dimension <code>nrow(x)</code> by <code>ncolx</code>.
</p>
</td></tr>
<tr valign="top"><td><code>values</code></td>
<td>
 
<p>Numeric.
The answer contains these values,
which are recycled <em>columnwise</em> if necessary, i.e.,
as <code>matrix(values, ..., byrow=TRUE)</code>.
</p>
</td></tr>
<tr valign="top"><td><code>ncolx</code></td>
<td>
 
<p>The number of columns of the returned matrix.
The default is the number of columns of <code>x</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>xij</code> argument for <code><a href="vglm.html">vglm</a></code> allows the user to input
variables specific to each linear/additive predictor.
For example, consider
the bivariate logit model where the first/second linear/additive
predictor is the logistic regression of the first/second binary response
respectively. The third linear/additive predictor is <code>log(OR) =
  eta3</code>, where <code>OR</code> is the odds ratio.  If one has ocular pressure
as a covariate in this model then <code>xij</code> is required to handle the
ocular pressure for each eye, since these will be different in general.
[This contrasts with a variable such as <code>age</code>, the age of the
person, which has a common value for both eyes.]  In order to input
these data into <code><a href="vglm.html">vglm</a></code> one often finds that functions
<code>fill</code>, <code>fill1</code>, etc. are useful.
</p>
<p>All terms in the <code>xij</code>
and <code>formula</code> arguments in <code><a href="vglm.html">vglm</a></code>
must appear in the <code>form2</code> argument too.
</p>


<h3>Value</h3>

<p><code>matrix(values, nrow=nrow(x), ncol=ncolx)</code>, i.e., a matrix
consisting of values <code>values</code>, with the number of rows matching
<code>x</code>, and the default number of columns is the number of columns
of <code>x</code>.
</p>


<h3>Note</h3>

 
<p>The effect of the <code>xij</code> argument is after other arguments such as
<code>exchangeable</code> and <code>zero</code>.
Hence <code>xij</code> does not affect constraint matrices.
</p>
<p>Additionally, there are currently 3 other identical <code>fill</code>
functions, called <code>fill1</code>, <code>fill2</code> and <code>fill3</code>;
if you need more then assign <code>fill4 = fill5 = fill1</code> etc.
The reason for this is that if more than one <code>fill</code> function is
needed then they must be unique.
For example, if <i>M=4</i> then 
<code>xij = op ~ lop + rop + fill(mop) + fill(mop)</code> would reduce to 
<code>xij = op ~ lop + rop + fill(mop)</code>, whereas
<code>xij = op ~ lop + rop + fill1(mop) + fill2(mop)</code> would retain
all <i>M</i> terms, which is needed.
</p>


<p>In Examples 1 to 3 below, the <code>xij</code> argument illustrates covariates
that are specific to a linear predictor. Here, <code>lop</code>/<code>rop</code> are
the ocular pressures of the left/right eye in an artificial dataset,
and <code>mop</code> is their mean. Variables <code>leye</code> and <code>reye</code>
might be the presence/absence of a particular disease on the LHS/RHS
eye respectively.
</p>





<p>In Example 3,
the <code>xij</code> argument illustrates fitting the (exchangeable) model
where there
is a common smooth function of the ocular pressure. One should use
regression splines since <code><a href="s.html">s</a></code> in <code><a href="vgam.html">vgam</a></code> does not
handle the <code>xij</code> argument.  However, regression splines such as
<code><a href="../../splines/html/bs.html">bs</a></code> and <code><a href="../../splines/html/ns.html">ns</a></code> need to have
the same basis functions here for both functions, and Example 3 illustrates
a trick involving a function <code>BS</code> to obtain this, e.g., same knots.
Although regression splines create more than a single column per term
in the model matrix, <code>fill(BS(lop,rop))</code> creates the required
(same) number of columns.
</p>


<h3>Author(s)</h3>

<p> T. W. Yee </p>


<h3>See Also</h3>

 
<p><code><a href="vglm.control.html">vglm.control</a></code>,
<code><a href="vglm.html">vglm</a></code>,
<code><a href="multinomial.html">multinomial</a></code>,
<code><a href="Select.html">Select</a></code>.
</p>


<h3>Examples</h3>

<pre>
fill(runif(5))
fill(runif(5), ncol = 3)
fill(runif(5), val = 1, ncol = 3)

# Generate eyes data for the examples below. Eyes are independent (OR=1).
nn &lt;- 1000  # Number of people
eyesdata &lt;- data.frame(lop = round(runif(nn), 2),
                       rop = round(runif(nn), 2),
                       age = round(rnorm(nn, 40, 10)))
eyesdata &lt;- transform(eyesdata,
    mop = (lop + rop) / 2,        # Mean ocular pressure
    op  = (lop + rop) / 2,        # Value unimportant unless plotting
#   op  =  lop,                   # Choose this if plotting
    eta1 = 0 - 2*lop + 0.04*age,  # Linear predictor for left eye
    eta2 = 0 - 2*rop + 0.04*age)  # Linear predictor for right eye
eyesdata &lt;- transform(eyesdata,
    leye = rbinom(nn, size = 1, prob = logit(eta1, inverse = TRUE)),
    reye = rbinom(nn, size = 1, prob = logit(eta2, inverse = TRUE)))

# Example 1
# All effects are linear
fit1 &lt;- vglm(cbind(leye,reye) ~ op + age,
             family = binom2.or(exchangeable = TRUE, zero = 3),
             data = eyesdata, trace = TRUE,
             xij = list(op ~ lop + rop + fill(lop)),
             form2 =  ~ op + lop + rop + fill(lop) + age)
head(model.matrix(fit1, type = "lm"))   # LM model matrix
head(model.matrix(fit1, type = "vlm"))  # Big VLM model matrix
coef(fit1)
coef(fit1, matrix = TRUE)  # Unchanged with 'xij'
constraints(fit1)
max(abs(predict(fit1)-predict(fit1, new = eyesdata)))  # Predicts correctly
summary(fit1)
## Not run: 
plotvgam(fit1, se = TRUE)  # Wrong, e.g., because it plots against op, not lop.
# So set op = lop in the above for a correct plot.

## End(Not run)



# Example 2
# Model OR as a linear function of mop
fit2 &lt;- vglm(cbind(leye,reye) ~ op + age, data = eyesdata, trace = TRUE,
            binom2.or(exchangeable = TRUE, zero = NULL),
            xij   = list(op ~ lop + rop + mop),
            form2 =    ~ op + lop + rop + mop + age)
head(model.matrix(fit2, type = "lm"))   # LM model matrix
head(model.matrix(fit2, type = "vlm"))  # Big VLM model matrix
coef(fit2)
coef(fit2, matrix = TRUE)  # Unchanged with 'xij'
max(abs(predict(fit2) - predict(fit2, new = eyesdata)))  # Predicts correctly
summary(fit2)
## Not run: 
plotvgam(fit2, se = TRUE)  # Wrong because it plots against op, not lop.

## End(Not run)


# Example 3. This model uses regression splines on ocular pressure.
# It uses a trick to ensure common basis functions.
BS &lt;- function(x, ...)
  sm.bs(c(x,...), df = 3)[1:length(x), , drop = FALSE]  # trick

fit3 &lt;- vglm(cbind(leye,reye) ~ BS(lop,rop) + age,
             family = binom2.or(exchangeable = TRUE, zero = 3),
             data = eyesdata, trace = TRUE,
             xij = list(BS(lop,rop) ~ BS(lop,rop) +
                                      BS(rop,lop) +
                                      fill(BS(lop,rop))),
             form2 = ~  BS(lop,rop) + BS(rop,lop) + fill(BS(lop,rop)) +
                        lop + rop + age)
head(model.matrix(fit3, type =  "lm"))  # LM model matrix
head(model.matrix(fit3, type = "vlm"))  # Big VLM model matrix
coef(fit3)
coef(fit3, matrix = TRUE)
summary(fit3)
fit3@smart.prediction
max(abs(predict(fit3) - predict(fit3, new = eyesdata)))  # Predicts correctly
predict(fit3, new = head(eyesdata))  # Note the 'scalar' OR, i.e., zero=3
max(abs(head(predict(fit3)) -
             predict(fit3, new = head(eyesdata))))  # Should be 0
## Not run: 
plotvgam(fit3, se = TRUE, xlab = "lop")  # Correct

## End(Not run)


# Example 4. Capture-recapture model with ephemeral and enduring
# memory effects. Similar to Yang and Chao (2005), Biometrics.
deermice &lt;- transform(deermice, Lag1 = y1)
M.tbh.lag1 &lt;-
  vglm(cbind(y1, y2, y3, y4, y5, y6) ~ sex + weight + Lag1,
       posbernoulli.tb(parallel.t = FALSE ~ 0,
                       parallel.b = FALSE ~ 0,
                       drop.b = FALSE ~ 1),
       xij = list(Lag1 ~ fill(y1) + fill(y2) + fill(y3) + fill(y4) +
                         fill(y5) + fill(y6) +
                         y1 + y2 + y3 + y4 + y5),
       form2 = ~ sex + weight + Lag1 +
                 fill(y1) + fill(y2) + fill(y3) + fill(y4) +
                 fill(y5) + fill(y6) +
                 y1 + y2 + y3 + y4 + y5 + y6,
       data = deermice, trace = TRUE)
coef(M.tbh.lag1)
</pre>

<hr /><div style="text-align: center;">[Package <em>VGAM</em> version 1.0-2 <a href="00Index.html">Index</a>]</div>
</body></html>
